<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyisc.dhcpd.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyisc.dhcpd.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Jonas Hallqvist

# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Tuple
from pyisc.dhcpd.nodes import (CustomOption, DhcpClass, Event, EventSet, Group,
                               Hardware, Host, Include, Key, Failover, Option,
                               OptionExpression, Pool4, Prefix6, Range4,
                               Range6, ServerDuidEN, ServerDuidLL, SubClass,
                               Subnet4, Subnet6, SharedNetwork, Zone)


class TokenProcessor:
    &#34;&#34;&#34;A processor class for tokens.

    This class takes a token and uses the lowercase token name to match a
    method. If a method is found it proceeds to run that method an return
    the value or object and the method to add it to the current working node.

    &#34;&#34;&#34;

    def switch(self, token) -&gt; Tuple:
        &#34;&#34;&#34;
        Returns a tuple of value/object and metod.

        Args:
            token (pyisc.dhcpd.parsing.Token): A supplied token instance.

        Returns:
            tuple: Tuple containing value or object in first position
                and method in second position.

        Examples:
            &gt;&gt;&gt; token = Token(type=&#39;OPTION&#39;,
            ...               value=&#39;option domain-name &#34;example.org&#34;;&#39;,
            ...               line=8, column=0)
            &gt;&gt;&gt; processor = TokenProcessor()
            &gt;&gt;&gt; declaration, method = processor.switch(token)
            &gt;&gt;&gt; declaration
            Option(name=&#34;domain_name&#34;, value=&#34;&#34;example.org&#34;&#34;)
            &gt;&gt;&gt; method
            &#39;add_option&#39;

        &#34;&#34;&#34;
        self.token = token
        return getattr(self, str(token.type).lower(), self.not_found)()

    def not_found(self):
        raise AttributeError(
            f&#39;Token {self.token.type} does not have a associated method.&#39;)

    def authoritative(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the authoritative command.&#34;&#34;&#34;
        if &#39;not&#39; in self.token.value:
            return (False, &#39;authoritative&#39;)
        return (True, &#39;authoritative&#39;)

    def hardware(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the hardware command.&#34;&#34;&#34;
        _, hardware_type, hardware_address = self.token.value[:-1].split()
        node_hardware = Hardware(type=hardware_type, address=hardware_address)
        return (node_hardware, &#39;hardware&#39;)

    def primary(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the zone primary command.&#34;&#34;&#34;
        _, primary = self.token.value[:-1].split()
        return (primary, &#39;primary&#39;)

    def failover_role(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the failover role.&#34;&#34;&#34;
        role = self.token.value[:-1]
        return (role, &#39;role&#39;)

    def include(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the include declaration.&#34;&#34;&#34;
        _, file_name = self.token.value[:-1].split()
        declaration = Include(filename=file_name)
        return (declaration, &#39;add_include&#39;)

    def general_parameter(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the all other parameters.&#34;&#34;&#34;
        key, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
        if value.isdigit():
            value = int(value)
        attr_key = key.replace(&#39;-&#39;, &#39;_&#39;).replace(&#39; &#39;, &#39;_&#39;)
        return (value, attr_key)

    def allow_member(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the allow member of statement.&#34;&#34;&#34;
        _, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
        return (value, &#39;add_allowed_member&#39;)

    def deny_member(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the deny member of statement.&#34;&#34;&#34;
        _, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
        return (value, &#39;add_denied_member&#39;)

    def allow_general(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the allow statement.&#34;&#34;&#34;
        _, key = self.token.value[:-1].split()
        key = key.replace(&#39;-&#39;, &#39;_&#39;)
        return (&#39;allow&#39;, key)

    def deny_general(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the deny statement.&#34;&#34;&#34;
        _, key = self.token.value[:-1].split()
        key = key.replace(&#39;-&#39;, &#39;_&#39;)
        return (&#39;deny&#39;, key)

    def ignore_general(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ignore statement.&#34;&#34;&#34;
        _, key = self.token.value[:-1].split()
        key = key.replace(&#39;-&#39;, &#39;_&#39;)
        return (&#39;ignore&#39;, key)

    def class_statement(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the match statement of the class declaration.&#34;&#34;&#34;
        _, statement = self.token.value[:-1].split(&#39; &#39;, 1)
        return (statement, &#39;match&#39;)

    def spawn_class(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the spawn statement of the class declaration.&#34;&#34;&#34;
        _, statement = self.token.value[:-1].split(&#39; &#39;, 1)
        return (statement, &#39;spawn&#39;)

    def range4(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the range statement for ipv4 configuration.&#34;&#34;&#34;
        cleaned_token = self.token.value[:-1].strip()
        range_list = [data.strip() for data in cleaned_token.split()]
        if &#39;dynamic-bootp&#39; in cleaned_token:
            dynamic_bootp = True
            range_list.remove(&#39;dynamic-bootp&#39;)
        else:
            dynamic_bootp = False
        while len(range_list) &lt; 3:
            range_list += [None]
        _, range_start, range_end = range_list
        subnet_range = Range4(
            start=range_start, end=range_end, dynamic_bootp=dynamic_bootp)
        return (subnet_range, &#39;add_range&#39;)

    def range6(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the range statement for ipv6 configuration.&#34;&#34;&#34;
        cleaned_token = self.token.value[:-1].strip()
        range_list = [data.strip() for data in cleaned_token.split()]
        if &#39;temporary&#39; in cleaned_token:
            temporary = True
            range_list.remove(&#39;temporary&#39;)
        else:
            temporary = False
        while len(range_list) &lt; 3:
            range_list += [None]
        _, range_start, range_end = range_list
        subnet_range = Range6(
            start=range_start, end=range_end, temporary=temporary)
        return (subnet_range, &#39;add_range&#39;)

    def option(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the option command.&#34;&#34;&#34;
        if self.token.value.count(&#39; &#39;) == 1:
            _, option = self.token.value[:-1].split()
            value = True
        else:
            _, option, value = self.token.value[:-1].split(&#39; &#39;, 2)
        if option.isdigit():
            node_option = Option(number=option, value=value)
        else:
            option = option.replace(&#39;-&#39;, &#39;_&#39;)
            node_option = Option(name=option, value=value)
        return (node_option, &#39;add_option&#39;)

    def custom_option(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the custom option command.&#34;&#34;&#34;
        _, option_name, _, code, _, value = self.token.value[:-1].split(&#39; &#39;, 5)
        return (CustomOption(name=option_name, code=code, definition=value),
                &#39;add_custom_option&#39;)

    def prefix6(self) -&gt; Tuple:
        _, start, end, bits = self.token.value[:-1].split()
        return (Prefix6(start=start, end=end, bits=bits), &#39;prefix6&#39;)

    def option_expression(self) -&gt; Tuple:
        _, option_name, _, value = self.token.value[:-1].split(&#39; &#39;, 3)
        return (OptionExpression(name=option_name, value=value),
                &#39;add_option_expression&#39;)

    def server_duid_ll(self) -&gt; Tuple:
        cleaned_token = self.token.value[:-1].strip()
        if &#39;LLT&#39; in cleaned_token:
            *_, hardware_type, timestamp, hardware_address = cleaned_token.split()
        else:
            *_, hardware_type, hardware_address, timestamp = cleaned_token.split() + [None]
        return (ServerDuidLL(hardware_type=hardware_type,
                             hardware_address=hardware_address,
                             timestamp=timestamp), &#39;server_duid&#39;)

    def server_duid_en(self) -&gt; Tuple:
        *_, enterprise_number, enterprise_id = self.token.value[:-1].split(&#39; &#39;, 3)
        return (ServerDuidEN(enterprise_number=enterprise_number,
                             enterprise_id=enterprise_id), &#39;server_duid&#39;)

    def key(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the key declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        if self.token.value[-1] == &#39;{&#39;:
            method = &#39;add_key&#39;
        else:
            method = &#39;key&#39;
        return (Key(name=name), method)

    def failover(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the failover declaration and parameter.&#34;&#34;&#34;
        *_, peer = self.token.value[:-1].split()
        return (Failover(name=peer), &#39;failover&#39;)

    def subnet4(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ipv4 subnet declaration.&#34;&#34;&#34;
        _, subnet, _, netmask = self.token.value[:-1].split()
        return (Subnet4(network=f&#39;{subnet}/{netmask}&#39;), &#39;add_subnet&#39;)

    def subnet6(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ipv4 subnet declaration.&#34;&#34;&#34;
        _, subnet_cidr = self.token.value[:-1].split()
        return (Subnet6(network=f&#39;{subnet_cidr}&#39;), &#39;add_subnet&#39;)

    def shared_network(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the shared network declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (SharedNetwork(name=name), &#39;add_shared_network&#39;)

    def pool(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ipv4 pool declaration.&#34;&#34;&#34;
        return (Pool4(), &#39;add_pool&#39;)

    def group(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the group declaration.&#34;&#34;&#34;
        return (Group(), &#39;add_group&#39;)

    def host(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the host declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (Host(name=name), &#39;add_host&#39;)

    def dhcp_class(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the class declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (DhcpClass(name=name), &#39;add_class&#39;)

    def subclass(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the class declaration and parameter.&#34;&#34;&#34;
        cleaned_token = self.token.value[:-1].strip()
        _, name, match_value = cleaned_token.split(&#39; &#39;, 2)
        return (SubClass(name=name, match_value=match_value), &#39;add_subclass&#39;)

    def zone(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the zone declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (Zone(name=name), &#39;add_zone&#39;)

    def event(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event declaration.&#34;&#34;&#34;
        _, event_type = self.token.value[:-1].split()
        return (Event(event_type=event_type), &#39;add_event&#39;)

    def event_set(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event set expression.&#34;&#34;&#34;
        key, value = [
            data.strip() for data in self.token.value[:-1].split(&#39;=&#39;)]
        _, attr_key = key.split()
        return (EventSet(key=attr_key, value=value), &#39;add_event_set&#39;)

    def event_log(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event log directive.&#34;&#34;&#34;
        value = self.token.value[:-1].replace(&#39;log&#39;, &#39;&#39;)
        return (value, &#39;log&#39;)

    def event_execute(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event execute directive.&#34;&#34;&#34;
        value = self.token.value[:-1].replace(&#39;execute&#39;, &#39;&#39;)
        return (value, &#39;execute&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyisc.dhcpd.utils.TokenProcessor"><code class="flex name class">
<span>class <span class="ident">TokenProcessor</span></span>
</code></dt>
<dd>
<div class="desc"><p>A processor class for tokens.</p>
<p>This class takes a token and uses the lowercase token name to match a
method. If a method is found it proceeds to run that method an return
the value or object and the method to add it to the current working node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TokenProcessor:
    &#34;&#34;&#34;A processor class for tokens.

    This class takes a token and uses the lowercase token name to match a
    method. If a method is found it proceeds to run that method an return
    the value or object and the method to add it to the current working node.

    &#34;&#34;&#34;

    def switch(self, token) -&gt; Tuple:
        &#34;&#34;&#34;
        Returns a tuple of value/object and metod.

        Args:
            token (pyisc.dhcpd.parsing.Token): A supplied token instance.

        Returns:
            tuple: Tuple containing value or object in first position
                and method in second position.

        Examples:
            &gt;&gt;&gt; token = Token(type=&#39;OPTION&#39;,
            ...               value=&#39;option domain-name &#34;example.org&#34;;&#39;,
            ...               line=8, column=0)
            &gt;&gt;&gt; processor = TokenProcessor()
            &gt;&gt;&gt; declaration, method = processor.switch(token)
            &gt;&gt;&gt; declaration
            Option(name=&#34;domain_name&#34;, value=&#34;&#34;example.org&#34;&#34;)
            &gt;&gt;&gt; method
            &#39;add_option&#39;

        &#34;&#34;&#34;
        self.token = token
        return getattr(self, str(token.type).lower(), self.not_found)()

    def not_found(self):
        raise AttributeError(
            f&#39;Token {self.token.type} does not have a associated method.&#39;)

    def authoritative(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the authoritative command.&#34;&#34;&#34;
        if &#39;not&#39; in self.token.value:
            return (False, &#39;authoritative&#39;)
        return (True, &#39;authoritative&#39;)

    def hardware(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the hardware command.&#34;&#34;&#34;
        _, hardware_type, hardware_address = self.token.value[:-1].split()
        node_hardware = Hardware(type=hardware_type, address=hardware_address)
        return (node_hardware, &#39;hardware&#39;)

    def primary(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the zone primary command.&#34;&#34;&#34;
        _, primary = self.token.value[:-1].split()
        return (primary, &#39;primary&#39;)

    def failover_role(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the failover role.&#34;&#34;&#34;
        role = self.token.value[:-1]
        return (role, &#39;role&#39;)

    def include(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the include declaration.&#34;&#34;&#34;
        _, file_name = self.token.value[:-1].split()
        declaration = Include(filename=file_name)
        return (declaration, &#39;add_include&#39;)

    def general_parameter(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the all other parameters.&#34;&#34;&#34;
        key, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
        if value.isdigit():
            value = int(value)
        attr_key = key.replace(&#39;-&#39;, &#39;_&#39;).replace(&#39; &#39;, &#39;_&#39;)
        return (value, attr_key)

    def allow_member(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the allow member of statement.&#34;&#34;&#34;
        _, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
        return (value, &#39;add_allowed_member&#39;)

    def deny_member(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the deny member of statement.&#34;&#34;&#34;
        _, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
        return (value, &#39;add_denied_member&#39;)

    def allow_general(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the allow statement.&#34;&#34;&#34;
        _, key = self.token.value[:-1].split()
        key = key.replace(&#39;-&#39;, &#39;_&#39;)
        return (&#39;allow&#39;, key)

    def deny_general(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the deny statement.&#34;&#34;&#34;
        _, key = self.token.value[:-1].split()
        key = key.replace(&#39;-&#39;, &#39;_&#39;)
        return (&#39;deny&#39;, key)

    def ignore_general(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ignore statement.&#34;&#34;&#34;
        _, key = self.token.value[:-1].split()
        key = key.replace(&#39;-&#39;, &#39;_&#39;)
        return (&#39;ignore&#39;, key)

    def class_statement(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the match statement of the class declaration.&#34;&#34;&#34;
        _, statement = self.token.value[:-1].split(&#39; &#39;, 1)
        return (statement, &#39;match&#39;)

    def spawn_class(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the spawn statement of the class declaration.&#34;&#34;&#34;
        _, statement = self.token.value[:-1].split(&#39; &#39;, 1)
        return (statement, &#39;spawn&#39;)

    def range4(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the range statement for ipv4 configuration.&#34;&#34;&#34;
        cleaned_token = self.token.value[:-1].strip()
        range_list = [data.strip() for data in cleaned_token.split()]
        if &#39;dynamic-bootp&#39; in cleaned_token:
            dynamic_bootp = True
            range_list.remove(&#39;dynamic-bootp&#39;)
        else:
            dynamic_bootp = False
        while len(range_list) &lt; 3:
            range_list += [None]
        _, range_start, range_end = range_list
        subnet_range = Range4(
            start=range_start, end=range_end, dynamic_bootp=dynamic_bootp)
        return (subnet_range, &#39;add_range&#39;)

    def range6(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the range statement for ipv6 configuration.&#34;&#34;&#34;
        cleaned_token = self.token.value[:-1].strip()
        range_list = [data.strip() for data in cleaned_token.split()]
        if &#39;temporary&#39; in cleaned_token:
            temporary = True
            range_list.remove(&#39;temporary&#39;)
        else:
            temporary = False
        while len(range_list) &lt; 3:
            range_list += [None]
        _, range_start, range_end = range_list
        subnet_range = Range6(
            start=range_start, end=range_end, temporary=temporary)
        return (subnet_range, &#39;add_range&#39;)

    def option(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the option command.&#34;&#34;&#34;
        if self.token.value.count(&#39; &#39;) == 1:
            _, option = self.token.value[:-1].split()
            value = True
        else:
            _, option, value = self.token.value[:-1].split(&#39; &#39;, 2)
        if option.isdigit():
            node_option = Option(number=option, value=value)
        else:
            option = option.replace(&#39;-&#39;, &#39;_&#39;)
            node_option = Option(name=option, value=value)
        return (node_option, &#39;add_option&#39;)

    def custom_option(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the custom option command.&#34;&#34;&#34;
        _, option_name, _, code, _, value = self.token.value[:-1].split(&#39; &#39;, 5)
        return (CustomOption(name=option_name, code=code, definition=value),
                &#39;add_custom_option&#39;)

    def prefix6(self) -&gt; Tuple:
        _, start, end, bits = self.token.value[:-1].split()
        return (Prefix6(start=start, end=end, bits=bits), &#39;prefix6&#39;)

    def option_expression(self) -&gt; Tuple:
        _, option_name, _, value = self.token.value[:-1].split(&#39; &#39;, 3)
        return (OptionExpression(name=option_name, value=value),
                &#39;add_option_expression&#39;)

    def server_duid_ll(self) -&gt; Tuple:
        cleaned_token = self.token.value[:-1].strip()
        if &#39;LLT&#39; in cleaned_token:
            *_, hardware_type, timestamp, hardware_address = cleaned_token.split()
        else:
            *_, hardware_type, hardware_address, timestamp = cleaned_token.split() + [None]
        return (ServerDuidLL(hardware_type=hardware_type,
                             hardware_address=hardware_address,
                             timestamp=timestamp), &#39;server_duid&#39;)

    def server_duid_en(self) -&gt; Tuple:
        *_, enterprise_number, enterprise_id = self.token.value[:-1].split(&#39; &#39;, 3)
        return (ServerDuidEN(enterprise_number=enterprise_number,
                             enterprise_id=enterprise_id), &#39;server_duid&#39;)

    def key(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the key declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        if self.token.value[-1] == &#39;{&#39;:
            method = &#39;add_key&#39;
        else:
            method = &#39;key&#39;
        return (Key(name=name), method)

    def failover(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the failover declaration and parameter.&#34;&#34;&#34;
        *_, peer = self.token.value[:-1].split()
        return (Failover(name=peer), &#39;failover&#39;)

    def subnet4(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ipv4 subnet declaration.&#34;&#34;&#34;
        _, subnet, _, netmask = self.token.value[:-1].split()
        return (Subnet4(network=f&#39;{subnet}/{netmask}&#39;), &#39;add_subnet&#39;)

    def subnet6(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ipv4 subnet declaration.&#34;&#34;&#34;
        _, subnet_cidr = self.token.value[:-1].split()
        return (Subnet6(network=f&#39;{subnet_cidr}&#39;), &#39;add_subnet&#39;)

    def shared_network(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the shared network declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (SharedNetwork(name=name), &#39;add_shared_network&#39;)

    def pool(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the ipv4 pool declaration.&#34;&#34;&#34;
        return (Pool4(), &#39;add_pool&#39;)

    def group(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the group declaration.&#34;&#34;&#34;
        return (Group(), &#39;add_group&#39;)

    def host(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the host declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (Host(name=name), &#39;add_host&#39;)

    def dhcp_class(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the class declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (DhcpClass(name=name), &#39;add_class&#39;)

    def subclass(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the class declaration and parameter.&#34;&#34;&#34;
        cleaned_token = self.token.value[:-1].strip()
        _, name, match_value = cleaned_token.split(&#39; &#39;, 2)
        return (SubClass(name=name, match_value=match_value), &#39;add_subclass&#39;)

    def zone(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the zone declaration.&#34;&#34;&#34;
        _, name = self.token.value[:-1].split()
        return (Zone(name=name), &#39;add_zone&#39;)

    def event(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event declaration.&#34;&#34;&#34;
        _, event_type = self.token.value[:-1].split()
        return (Event(event_type=event_type), &#39;add_event&#39;)

    def event_set(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event set expression.&#34;&#34;&#34;
        key, value = [
            data.strip() for data in self.token.value[:-1].split(&#39;=&#39;)]
        _, attr_key = key.split()
        return (EventSet(key=attr_key, value=value), &#39;add_event_set&#39;)

    def event_log(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event log directive.&#34;&#34;&#34;
        value = self.token.value[:-1].replace(&#39;log&#39;, &#39;&#39;)
        return (value, &#39;log&#39;)

    def event_execute(self) -&gt; Tuple:
        &#34;&#34;&#34;Returns tuple for the event execute directive.&#34;&#34;&#34;
        value = self.token.value[:-1].replace(&#39;execute&#39;, &#39;&#39;)
        return (value, &#39;execute&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.utils.TokenProcessor.allow_general"><code class="name flex">
<span>def <span class="ident">allow_general</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the allow statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allow_general(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the allow statement.&#34;&#34;&#34;
    _, key = self.token.value[:-1].split()
    key = key.replace(&#39;-&#39;, &#39;_&#39;)
    return (&#39;allow&#39;, key)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.allow_member"><code class="name flex">
<span>def <span class="ident">allow_member</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the allow member of statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allow_member(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the allow member of statement.&#34;&#34;&#34;
    _, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
    return (value, &#39;add_allowed_member&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.authoritative"><code class="name flex">
<span>def <span class="ident">authoritative</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the authoritative command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def authoritative(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the authoritative command.&#34;&#34;&#34;
    if &#39;not&#39; in self.token.value:
        return (False, &#39;authoritative&#39;)
    return (True, &#39;authoritative&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.class_statement"><code class="name flex">
<span>def <span class="ident">class_statement</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the match statement of the class declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def class_statement(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the match statement of the class declaration.&#34;&#34;&#34;
    _, statement = self.token.value[:-1].split(&#39; &#39;, 1)
    return (statement, &#39;match&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.custom_option"><code class="name flex">
<span>def <span class="ident">custom_option</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the custom option command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_option(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the custom option command.&#34;&#34;&#34;
    _, option_name, _, code, _, value = self.token.value[:-1].split(&#39; &#39;, 5)
    return (CustomOption(name=option_name, code=code, definition=value),
            &#39;add_custom_option&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.deny_general"><code class="name flex">
<span>def <span class="ident">deny_general</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the deny statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deny_general(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the deny statement.&#34;&#34;&#34;
    _, key = self.token.value[:-1].split()
    key = key.replace(&#39;-&#39;, &#39;_&#39;)
    return (&#39;deny&#39;, key)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.deny_member"><code class="name flex">
<span>def <span class="ident">deny_member</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the deny member of statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deny_member(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the deny member of statement.&#34;&#34;&#34;
    _, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
    return (value, &#39;add_denied_member&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.dhcp_class"><code class="name flex">
<span>def <span class="ident">dhcp_class</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the class declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dhcp_class(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the class declaration.&#34;&#34;&#34;
    _, name = self.token.value[:-1].split()
    return (DhcpClass(name=name), &#39;add_class&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.event"><code class="name flex">
<span>def <span class="ident">event</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the event declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the event declaration.&#34;&#34;&#34;
    _, event_type = self.token.value[:-1].split()
    return (Event(event_type=event_type), &#39;add_event&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.event_execute"><code class="name flex">
<span>def <span class="ident">event_execute</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the event execute directive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_execute(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the event execute directive.&#34;&#34;&#34;
    value = self.token.value[:-1].replace(&#39;execute&#39;, &#39;&#39;)
    return (value, &#39;execute&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.event_log"><code class="name flex">
<span>def <span class="ident">event_log</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the event log directive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_log(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the event log directive.&#34;&#34;&#34;
    value = self.token.value[:-1].replace(&#39;log&#39;, &#39;&#39;)
    return (value, &#39;log&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.event_set"><code class="name flex">
<span>def <span class="ident">event_set</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the event set expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_set(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the event set expression.&#34;&#34;&#34;
    key, value = [
        data.strip() for data in self.token.value[:-1].split(&#39;=&#39;)]
    _, attr_key = key.split()
    return (EventSet(key=attr_key, value=value), &#39;add_event_set&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.failover"><code class="name flex">
<span>def <span class="ident">failover</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the failover declaration and parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def failover(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the failover declaration and parameter.&#34;&#34;&#34;
    *_, peer = self.token.value[:-1].split()
    return (Failover(name=peer), &#39;failover&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.failover_role"><code class="name flex">
<span>def <span class="ident">failover_role</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the failover role.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def failover_role(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the failover role.&#34;&#34;&#34;
    role = self.token.value[:-1]
    return (role, &#39;role&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.general_parameter"><code class="name flex">
<span>def <span class="ident">general_parameter</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the all other parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def general_parameter(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the all other parameters.&#34;&#34;&#34;
    key, value = self.token.value[:-1].rsplit(&#39; &#39;, 1)
    if value.isdigit():
        value = int(value)
    attr_key = key.replace(&#39;-&#39;, &#39;_&#39;).replace(&#39; &#39;, &#39;_&#39;)
    return (value, attr_key)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.group"><code class="name flex">
<span>def <span class="ident">group</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the group declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the group declaration.&#34;&#34;&#34;
    return (Group(), &#39;add_group&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.hardware"><code class="name flex">
<span>def <span class="ident">hardware</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the hardware command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hardware(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the hardware command.&#34;&#34;&#34;
    _, hardware_type, hardware_address = self.token.value[:-1].split()
    node_hardware = Hardware(type=hardware_type, address=hardware_address)
    return (node_hardware, &#39;hardware&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.host"><code class="name flex">
<span>def <span class="ident">host</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the host declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def host(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the host declaration.&#34;&#34;&#34;
    _, name = self.token.value[:-1].split()
    return (Host(name=name), &#39;add_host&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.ignore_general"><code class="name flex">
<span>def <span class="ident">ignore_general</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the ignore statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ignore_general(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the ignore statement.&#34;&#34;&#34;
    _, key = self.token.value[:-1].split()
    key = key.replace(&#39;-&#39;, &#39;_&#39;)
    return (&#39;ignore&#39;, key)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.include"><code class="name flex">
<span>def <span class="ident">include</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the include declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def include(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the include declaration.&#34;&#34;&#34;
    _, file_name = self.token.value[:-1].split()
    declaration = Include(filename=file_name)
    return (declaration, &#39;add_include&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.key"><code class="name flex">
<span>def <span class="ident">key</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the key declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the key declaration.&#34;&#34;&#34;
    _, name = self.token.value[:-1].split()
    if self.token.value[-1] == &#39;{&#39;:
        method = &#39;add_key&#39;
    else:
        method = &#39;key&#39;
    return (Key(name=name), method)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.not_found"><code class="name flex">
<span>def <span class="ident">not_found</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_found(self):
    raise AttributeError(
        f&#39;Token {self.token.type} does not have a associated method.&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.option"><code class="name flex">
<span>def <span class="ident">option</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the option command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def option(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the option command.&#34;&#34;&#34;
    if self.token.value.count(&#39; &#39;) == 1:
        _, option = self.token.value[:-1].split()
        value = True
    else:
        _, option, value = self.token.value[:-1].split(&#39; &#39;, 2)
    if option.isdigit():
        node_option = Option(number=option, value=value)
    else:
        option = option.replace(&#39;-&#39;, &#39;_&#39;)
        node_option = Option(name=option, value=value)
    return (node_option, &#39;add_option&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.option_expression"><code class="name flex">
<span>def <span class="ident">option_expression</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def option_expression(self) -&gt; Tuple:
    _, option_name, _, value = self.token.value[:-1].split(&#39; &#39;, 3)
    return (OptionExpression(name=option_name, value=value),
            &#39;add_option_expression&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.pool"><code class="name flex">
<span>def <span class="ident">pool</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the ipv4 pool declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pool(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the ipv4 pool declaration.&#34;&#34;&#34;
    return (Pool4(), &#39;add_pool&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.prefix6"><code class="name flex">
<span>def <span class="ident">prefix6</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prefix6(self) -&gt; Tuple:
    _, start, end, bits = self.token.value[:-1].split()
    return (Prefix6(start=start, end=end, bits=bits), &#39;prefix6&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.primary"><code class="name flex">
<span>def <span class="ident">primary</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the zone primary command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def primary(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the zone primary command.&#34;&#34;&#34;
    _, primary = self.token.value[:-1].split()
    return (primary, &#39;primary&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.range4"><code class="name flex">
<span>def <span class="ident">range4</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the range statement for ipv4 configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range4(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the range statement for ipv4 configuration.&#34;&#34;&#34;
    cleaned_token = self.token.value[:-1].strip()
    range_list = [data.strip() for data in cleaned_token.split()]
    if &#39;dynamic-bootp&#39; in cleaned_token:
        dynamic_bootp = True
        range_list.remove(&#39;dynamic-bootp&#39;)
    else:
        dynamic_bootp = False
    while len(range_list) &lt; 3:
        range_list += [None]
    _, range_start, range_end = range_list
    subnet_range = Range4(
        start=range_start, end=range_end, dynamic_bootp=dynamic_bootp)
    return (subnet_range, &#39;add_range&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.range6"><code class="name flex">
<span>def <span class="ident">range6</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the range statement for ipv6 configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range6(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the range statement for ipv6 configuration.&#34;&#34;&#34;
    cleaned_token = self.token.value[:-1].strip()
    range_list = [data.strip() for data in cleaned_token.split()]
    if &#39;temporary&#39; in cleaned_token:
        temporary = True
        range_list.remove(&#39;temporary&#39;)
    else:
        temporary = False
    while len(range_list) &lt; 3:
        range_list += [None]
    _, range_start, range_end = range_list
    subnet_range = Range6(
        start=range_start, end=range_end, temporary=temporary)
    return (subnet_range, &#39;add_range&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.server_duid_en"><code class="name flex">
<span>def <span class="ident">server_duid_en</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server_duid_en(self) -&gt; Tuple:
    *_, enterprise_number, enterprise_id = self.token.value[:-1].split(&#39; &#39;, 3)
    return (ServerDuidEN(enterprise_number=enterprise_number,
                         enterprise_id=enterprise_id), &#39;server_duid&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.server_duid_ll"><code class="name flex">
<span>def <span class="ident">server_duid_ll</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def server_duid_ll(self) -&gt; Tuple:
    cleaned_token = self.token.value[:-1].strip()
    if &#39;LLT&#39; in cleaned_token:
        *_, hardware_type, timestamp, hardware_address = cleaned_token.split()
    else:
        *_, hardware_type, hardware_address, timestamp = cleaned_token.split() + [None]
    return (ServerDuidLL(hardware_type=hardware_type,
                         hardware_address=hardware_address,
                         timestamp=timestamp), &#39;server_duid&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.shared_network"><code class="name flex">
<span>def <span class="ident">shared_network</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the shared network declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shared_network(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the shared network declaration.&#34;&#34;&#34;
    _, name = self.token.value[:-1].split()
    return (SharedNetwork(name=name), &#39;add_shared_network&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.spawn_class"><code class="name flex">
<span>def <span class="ident">spawn_class</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the spawn statement of the class declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_class(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the spawn statement of the class declaration.&#34;&#34;&#34;
    _, statement = self.token.value[:-1].split(&#39; &#39;, 1)
    return (statement, &#39;spawn&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.subclass"><code class="name flex">
<span>def <span class="ident">subclass</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the class declaration and parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subclass(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the class declaration and parameter.&#34;&#34;&#34;
    cleaned_token = self.token.value[:-1].strip()
    _, name, match_value = cleaned_token.split(&#39; &#39;, 2)
    return (SubClass(name=name, match_value=match_value), &#39;add_subclass&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.subnet4"><code class="name flex">
<span>def <span class="ident">subnet4</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the ipv4 subnet declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subnet4(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the ipv4 subnet declaration.&#34;&#34;&#34;
    _, subnet, _, netmask = self.token.value[:-1].split()
    return (Subnet4(network=f&#39;{subnet}/{netmask}&#39;), &#39;add_subnet&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.subnet6"><code class="name flex">
<span>def <span class="ident">subnet6</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the ipv4 subnet declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subnet6(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the ipv4 subnet declaration.&#34;&#34;&#34;
    _, subnet_cidr = self.token.value[:-1].split()
    return (Subnet6(network=f&#39;{subnet_cidr}&#39;), &#39;add_subnet&#39;)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.switch"><code class="name flex">
<span>def <span class="ident">switch</span></span>(<span>self, token) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of value/object and metod.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code><a title="pyisc.dhcpd.parsing.Token" href="parsing.html#pyisc.dhcpd.parsing.Token">Token</a></code></dt>
<dd>A supplied token instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple containing value or object in first position
and method in second position.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; token = Token(type='OPTION',
...               value='option domain-name &quot;example.org&quot;;',
...               line=8, column=0)
&gt;&gt;&gt; processor = TokenProcessor()
&gt;&gt;&gt; declaration, method = processor.switch(token)
&gt;&gt;&gt; declaration
Option(name=&quot;domain_name&quot;, value=&quot;&quot;example.org&quot;&quot;)
&gt;&gt;&gt; method
'add_option'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch(self, token) -&gt; Tuple:
    &#34;&#34;&#34;
    Returns a tuple of value/object and metod.

    Args:
        token (pyisc.dhcpd.parsing.Token): A supplied token instance.

    Returns:
        tuple: Tuple containing value or object in first position
            and method in second position.

    Examples:
        &gt;&gt;&gt; token = Token(type=&#39;OPTION&#39;,
        ...               value=&#39;option domain-name &#34;example.org&#34;;&#39;,
        ...               line=8, column=0)
        &gt;&gt;&gt; processor = TokenProcessor()
        &gt;&gt;&gt; declaration, method = processor.switch(token)
        &gt;&gt;&gt; declaration
        Option(name=&#34;domain_name&#34;, value=&#34;&#34;example.org&#34;&#34;)
        &gt;&gt;&gt; method
        &#39;add_option&#39;

    &#34;&#34;&#34;
    self.token = token
    return getattr(self, str(token.type).lower(), self.not_found)()</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.utils.TokenProcessor.zone"><code class="name flex">
<span>def <span class="ident">zone</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Returns tuple for the zone declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zone(self) -&gt; Tuple:
    &#34;&#34;&#34;Returns tuple for the zone declaration.&#34;&#34;&#34;
    _, name = self.token.value[:-1].split()
    return (Zone(name=name), &#39;add_zone&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyisc.dhcpd" href="index.html">pyisc.dhcpd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyisc.dhcpd.utils.TokenProcessor" href="#pyisc.dhcpd.utils.TokenProcessor">TokenProcessor</a></code></h4>
<ul class="two-column">
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.allow_general" href="#pyisc.dhcpd.utils.TokenProcessor.allow_general">allow_general</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.allow_member" href="#pyisc.dhcpd.utils.TokenProcessor.allow_member">allow_member</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.authoritative" href="#pyisc.dhcpd.utils.TokenProcessor.authoritative">authoritative</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.class_statement" href="#pyisc.dhcpd.utils.TokenProcessor.class_statement">class_statement</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.custom_option" href="#pyisc.dhcpd.utils.TokenProcessor.custom_option">custom_option</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.deny_general" href="#pyisc.dhcpd.utils.TokenProcessor.deny_general">deny_general</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.deny_member" href="#pyisc.dhcpd.utils.TokenProcessor.deny_member">deny_member</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.dhcp_class" href="#pyisc.dhcpd.utils.TokenProcessor.dhcp_class">dhcp_class</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.event" href="#pyisc.dhcpd.utils.TokenProcessor.event">event</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.event_execute" href="#pyisc.dhcpd.utils.TokenProcessor.event_execute">event_execute</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.event_log" href="#pyisc.dhcpd.utils.TokenProcessor.event_log">event_log</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.event_set" href="#pyisc.dhcpd.utils.TokenProcessor.event_set">event_set</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.failover" href="#pyisc.dhcpd.utils.TokenProcessor.failover">failover</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.failover_role" href="#pyisc.dhcpd.utils.TokenProcessor.failover_role">failover_role</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.general_parameter" href="#pyisc.dhcpd.utils.TokenProcessor.general_parameter">general_parameter</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.group" href="#pyisc.dhcpd.utils.TokenProcessor.group">group</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.hardware" href="#pyisc.dhcpd.utils.TokenProcessor.hardware">hardware</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.host" href="#pyisc.dhcpd.utils.TokenProcessor.host">host</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.ignore_general" href="#pyisc.dhcpd.utils.TokenProcessor.ignore_general">ignore_general</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.include" href="#pyisc.dhcpd.utils.TokenProcessor.include">include</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.key" href="#pyisc.dhcpd.utils.TokenProcessor.key">key</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.not_found" href="#pyisc.dhcpd.utils.TokenProcessor.not_found">not_found</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.option" href="#pyisc.dhcpd.utils.TokenProcessor.option">option</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.option_expression" href="#pyisc.dhcpd.utils.TokenProcessor.option_expression">option_expression</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.pool" href="#pyisc.dhcpd.utils.TokenProcessor.pool">pool</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.prefix6" href="#pyisc.dhcpd.utils.TokenProcessor.prefix6">prefix6</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.primary" href="#pyisc.dhcpd.utils.TokenProcessor.primary">primary</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.range4" href="#pyisc.dhcpd.utils.TokenProcessor.range4">range4</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.range6" href="#pyisc.dhcpd.utils.TokenProcessor.range6">range6</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.server_duid_en" href="#pyisc.dhcpd.utils.TokenProcessor.server_duid_en">server_duid_en</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.server_duid_ll" href="#pyisc.dhcpd.utils.TokenProcessor.server_duid_ll">server_duid_ll</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.shared_network" href="#pyisc.dhcpd.utils.TokenProcessor.shared_network">shared_network</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.spawn_class" href="#pyisc.dhcpd.utils.TokenProcessor.spawn_class">spawn_class</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.subclass" href="#pyisc.dhcpd.utils.TokenProcessor.subclass">subclass</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.subnet4" href="#pyisc.dhcpd.utils.TokenProcessor.subnet4">subnet4</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.subnet6" href="#pyisc.dhcpd.utils.TokenProcessor.subnet6">subnet6</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.switch" href="#pyisc.dhcpd.utils.TokenProcessor.switch">switch</a></code></li>
<li><code><a title="pyisc.dhcpd.utils.TokenProcessor.zone" href="#pyisc.dhcpd.utils.TokenProcessor.zone">zone</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>