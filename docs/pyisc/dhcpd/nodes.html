<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyisc.dhcpd.nodes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyisc.dhcpd.nodes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 Jonas Hallqvist

# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import List, Union
from ipaddress import IPv4Network, IPv6Network
from pyisc.dhcpd.mixin import (EventMixin, EventSetMixin, KeyMixin, Parameters,
                               OptionMixin, Permissions, PoolMixin, RangeMixin,
                               SubnetMixin, SharedNetworkMixin, GroupMixin,
                               HostMixin, ClassMixin, SubClassMixin, ZoneMixin,
                               IncludeMixin)

# TODO:
# Add the match_if attribute to DhcpClass and make changes to current parsing
# to match the new attribute. Also add Token psec and parsing for regular match
# (without the if).

# Try to reduce the number of variants of the to_isc method. Ideally there
# should be two versions - one for parameter like object that only take the
# __str__() and add the &#39;;&#39; and one for declaration objects.

# Move Parameters and Permissions to a seperate file - they do not belong in
# mixin


# Parameter classes
class CustomOption:
    &#34;&#34;&#34;Represents an custom dhcp option definition.&#34;&#34;&#34;
    def __init__(
        self,
        name:       str,
        code:       int,
        definition: str
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the dhcp option.
            code (int): The number of the dhcp option.
            definition (str): The definition of the option.

        &#34;&#34;&#34;
        self.name = name
        self.code = code
        self.definition = definition

    def __str__(self) -&gt; str:
        return f&#39;option {self.name} code {self.code} = {self.definition}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;CustomOption(name={self.name}, code={self.code}, &#39;
                f&#39;definition={self.definition})&#39;)

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; new_option = CustomOption(name=&#39;client-arch-type&#39;, code=93,
                                          definition=&#39;unsigned integer 16&#39;)
            &gt;&gt;&gt; print(new_option.to_isc())
            option client-arch-type code 93 = unsigned integer 16;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class EventSet:
    &#34;&#34;&#34;Represents an set expression for event objects.&#34;&#34;&#34;
    def __init__(self, key: str, value: str) -&gt; None:
        self.key = key
        self.value = value

    def __str__(self) -&gt; str:
        return f&#39;set {self.key} = {self.value}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;EventSet(key={self.key}, value={self.value})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; event_set = EventSet(key=&#39;clip&#39;,
                        value=&#39;binary-to-ascii(10, 8, &#34;.&#34;, leased-address)&#39;)
            &gt;&gt;&gt; print(event_set.to_isc())
            set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class Hardware:
    &#34;&#34;&#34;Represents an hardware parameter.&#34;&#34;&#34;
    def __init__(
        self,
        type:       str,
        address:    str
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            type (str): The type of the hardware instance.
            address (str): The address of the hardware instance.

        &#34;&#34;&#34;
        self.type = type
        self.address = address

    def __str__(self) -&gt; str:
        return f&#39;hardware {self.type} {self.address}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Hardware(type=&#34;{self.type}&#34;, address=&#34;{self.address}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; hardware = Hardware(type=&#39;ethernet&#39;, address=&#39;1234:5678:9abc&#39;)
            &gt;&gt;&gt; print(hardware.to_isc())
            hardware ethernet 1234:5678:9abc;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class HostIdentifier:
    &#34;&#34;&#34;Represents an host identifier parameter.&#34;&#34;&#34;
    def __init__(
        self,
        option_name:    str,
        option_data:    str,
        number:         Union[int, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            option_name (str): The name of the option.
            option_data (str): The value of the option.
            number (int): Relay number. If used this will automatically change
                the outputted isc configuration string to a v6relopt.

        &#34;&#34;&#34;
        self.option_name = option_name
        self.option_data = option_data
        self.number = number

    def __str__(self) -&gt; str:
        if self.number:
            base_string = f&#39;host-identifier v6relopt {self.number}&#39;
        else:
            base_string = &#39;host-identifier option&#39;
        return f&#39;{base_string} {self.option_name} {self.option_data}&#39;

    def __repr__(self) -&gt; str:
        if self.number:
            return (f&#39;HostIdentifier(&#39;
                    f&#39;number={self.number}, option_name={self.option_name},&#39;
                    f&#39;option_data={self.option_data})&#39;)
        else:
            return (f&#39;HostIdentifier(option_name={self.option_name}, &#39;
                    f&#39;option_data={self.option_data})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        The output is dependant upon what attributes are set. If number is set
        it is assumed that the host identifier is of the v6relopt type and the
        produced configuration will reflect that.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; host_id = HostIdentifier(option_name=&#39;domain-name&#39;,
                                         option_data=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; print(host_id.to_isc())
            host-identifier option domain-name &#34;example.org&#34;;

            &gt;&gt;&gt; host_id = HostIdentifier(option_name=&#39;domain-name&#39;,
                                         option_data=&#39;&#34;example.org&#34;&#39;, number=1)
            &gt;&gt;&gt; print(host_id.to_isc())
            host-identifier v6relopt 1 domain-name &#34;example.org&#34;;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class Option:
    &#34;&#34;&#34;Represents an dhcp option.&#34;&#34;&#34;
    def __init__(
        self,
        value:  str,
        name:   Union[str, None] = None,
        number: Union[int, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Name or number (or both) must be given. If value contains a comma it
        is assumed that the value will be a list and the submitted string will
        be saved accordingly.

        Args:
            name (str): The name of the dhcp option.
            number (str): The number of the dhcp option.
            value (str): The value of the option.

        &#34;&#34;&#34;
        if not name and not number:
            raise TypeError(&#39;__init__() missing attribute: name or number&#39;)
        self.name = name
        self.number = number
        self.value = value

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, value: str):
        if &#39;,&#39; in str(value):
            self.__value = [x.strip() for x in value.split(&#39;,&#39;)]
        else:
            self.__value = value

    def __str__(self) -&gt; str:
        if isinstance(self.value, list):
            return (f&#39;option {self.name.replace(&#34;_&#34;,&#34;-&#34;) if self.name else self.number} &#39;
                    f&#39;{&#34;, &#34;.join(self.value)}&#39;)
        elif isinstance(self.value, bool):
            return (f&#39;option {self.name.replace(&#34;_&#34;,&#34;-&#34;) if self.name else self.number}&#39;)
        else:
            return (f&#39;option {self.name.replace(&#34;_&#34;,&#34;-&#34;) if self.name else self.number} &#39;
                    f&#39;{self.value}&#39;)

    def __repr__(self) -&gt; str:
        key = f&#39;name=&#34;{self.name}&#34;&#39; if self.name else f&#39;number=&#34;{self.number}&#34;&#39;
        if isinstance(self.value, list):
            value = f&#39;value={self.value}&#39;
        else:
            value = f&#39;value=&#34;{self.value}&#34;&#39;
        return f&#39;Option({key}, {value})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; print(option.to_isc())
            option domain-name &#34;example.org&#34;;

            &gt;&gt;&gt; option = Option(number=105, value=&#39;&#34;test&#34;&#39;)
            &gt;&gt;&gt; print(option.to_isc())
            option 105 &#34;test&#34;;

            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, number=98,
                                value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; print(option.to_isc())
            option domain-name &#34;example.org&#34;;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class OptionExpression:
    &#34;&#34;&#34;Represents option with an expression as its value.&#34;&#34;&#34;
    def __init__(
        self,
        name:   str,
        value:  str
    ) -&gt; None:
        self.name = name
        self.value = value

    def __str__(self) -&gt; str:
        return f&#39;option {self.name} = {self.value}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;OptionExpression(name={self.name}, value={self.value})&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class ServerDuidLL:
    def __init__(
        self,
        hardware_type:      str,
        hardware_address:   str,
        timestamp:          Union[int, None] = None
    ) -&gt; None:
        self.hardware_type = hardware_type
        self.hardware_address = hardware_address
        self.timestamp = timestamp

    def __str__(self) -&gt; str:
        if self.timestamp:
            return (f&#39;server-duid LLT {self.hardware_type} {self.timestamp} &#39;
                    f&#39;{self.hardware_address}&#39;)
        else:
            return (f&#39;server-duid LL {self.hardware_type} &#39;
                    f&#39;{self.hardware_address}&#39;)

    def __repr__(self) -&gt; str:
        return (f&#39;ServerDuidLL(hardware_type={self.hardware_type}, &#39;
                f&#39;hardware_address={self.hardware_address}, &#39;
                f&#39;timestamp={self.timestamp})&#39;)

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; pass

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class ServerDuidEN:
    &#34;&#34;&#34;Represents an server DUID enterprise parameter.&#34;&#34;&#34;
    def __init__(self, enterprise_number: int, enterprise_id: str) -&gt; None:
        self.enterprise_number = enterprise_number
        self.enterprise_id = enterprise_id

    def __str__(self) -&gt; str:
        return f&#39;server-duid EN {self.enterprise_number} {self.enterprise_id}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;ServerDuidEN(enterprise_number={self.enterprise_number}, &#39;
                f&#39;enterprise_id={self.enterprise_id})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; server_duid = ServerDuidEN(enterprise_number=9,
                              enterprise_id=&#39;&#34;a string of some significance&#34;&#39;)
            &gt;&gt;&gt; print(server_duid.to_isc())
            server-duid EN 9 &#34;a string of some significance&#34;;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


# Declarations
class DhcpClass:
    &#34;&#34;&#34;Represents an class declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:               str,
        always_broadcast:   Union[bool, None] = None,
        match:              Union[str, None] = None,
        spawn:              Union[str, None] = None,
        lease_limit:        Union[int, None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            always_broadcast (boolean): Broadcast even if broadcast flag is
                unset from clients.
            match (str): The conditional in the form of a string.
            spawn (str): The spawn argument in the form of a string.
            lease_limit (int): Sets the amount of clients that are allowed a
                lease

        &#34;&#34;&#34;
        self.name = name
        self.always_broadcast = always_broadcast
        self.match = match
        self.spawn = spawn
        self.lease_limit = lease_limit

    def __str__(self) -&gt; str:
        return f&#39;class {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;DhcpClass(name={self.name})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; dhcp_class = DhcpClass(name=&#39;foo&#39;)
            &gt;&gt;&gt; print(dhcp_class.to_isc())
            class foo {
            }

            &gt;&gt;&gt; dhcp_class.lease_limit = 4
            &gt;&gt;&gt; print(dhcp_class.to_isc())
            class foo {
                lease limit 4;
            }

            &gt;&gt;&gt; dhcp_class.match = &#39;if substring (option vendor-class-identifier, 0, 4) = &#34;SUNW&#34;&#39;
            &gt;&gt;&gt; print(dhcp_class.to_isc())
            class foo {
                match if substring (option vendor-class-identifier, 0, 4) = &#34;SUNW&#34;;
                lease limit 4;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        space_sep = (&#39;lease_limit&#39;)
        excluded_atts = (&#39;name&#39;)
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if key in space_sep:
                isc_key = key.replace(&#34;_&#34;, &#34; &#34;)
            else:
                isc_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if all((value, key not in excluded_atts)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{isc_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Event(EventSetMixin):
    &#34;&#34;&#34;Represents the event declaration.&#34;&#34;&#34;
    def __init__(
        self,
        event_type: str,
        event_sets: Union[List[EventSet], None] = None,
        execute:    Union[str, None] = None,
        log:        Union[str, None] = None
    ) -&gt; None:
        self.event_type = event_type
        self.event_sets = [] if not event_sets else event_sets
        self.execute = execute
        self.log = log

    def __str__(self) -&gt; str:
        return f&#39;on {self.event_type}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Event(event_type={self.event_type})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; event = Event(event_type=&#39;commit&#39;)
            &gt;&gt;&gt; print(event.to_isc())
            on commit {
            }

            &gt;&gt;&gt; event.add_event_set(
                EventSet(key=&#39;clip&#39;,
                    value=&#39;binary-to-ascii(10, 8, &#34;.&#34;, leased-address)&#39;))
            &gt;&gt;&gt; print(event.to_isc())
            on commit {
                set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);
            }

            &gt;&gt;&gt; event.execute = &#39;(&#34;/usr/local/sbin/dhcpevent&#34;, &#34;commit&#34;, clip, clhw, host-decl-name)&#39;
            &gt;&gt;&gt; print(event.to_isc())
            on commit {
                set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);
                execute (&#34;/usr/local/sbin/dhcpevent&#34;, &#34;commit&#34;, clip, clhw, host-decl-name);
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        excluded_atts = (&#39;event_type&#39;)
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((value, key not in excluded_atts)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Failover:
    &#34;&#34;&#34;Represents the Failover declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:                       str,
        role:                       Union[str, None] = None,
        address:                    Union[str, None] = None,
        peer_address:               Union[str, None] = None,
        port:                       Union[int, None] = None,
        peer_port:                  Union[int, None] = None,
        max_response_delay:         Union[int, None] = None,
        max_unacked_updates:        Union[int, None] = None,
        mclt:                       Union[int, None] = None,
        split:                      Union[int, None] = None,
        hba:                        Union[str, None] = None,
        load_balance_max_seconds:   Union[int, None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): A name for the failover peer.
            role (str): Should be either primary or secondary.
            address (str): The IP address of the server in string format.
            peer_address (str): The IP address of the failover peer server
                in string format.
            port (int): The TCP port that the server listens for connections
                from failover peer.
            peer_port (int): The TCP port that the server connects to its
                failover peer.
            max_response_delay (int): Sets maximum response delay.
            max_unacked_updates (int): Sets maximum for unacknowledged
                messages.
            mclt (int): Sets maximum client lead time.
            split (int): Sets split load between primary and secondary
                failover member.
            hba (str): Sets split load between primary and secondary
                failover member as a bitmap.
            load_balance_max_seconds (int): Sets cutoff for disabling load
                balance.

        &#34;&#34;&#34;
        self.name = name
        self.role = role
        self.address = address
        self.peer_address = peer_address
        self.port = port
        self.peer_port = peer_port
        self.max_response_delay = max_response_delay
        self.max_unacked_updates = max_unacked_updates
        self.mclt = mclt
        self.split = split
        self.hba = hba
        self.load_balance_max_seconds = load_balance_max_seconds

    def __str__(self) -&gt; str:
        return f&#39;failover peer {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Failover(name={self.name})&#39;

    def object_tree(self, indent=0):
        &#34;&#34;&#34;TEMP.&#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; failover = Failover(name=&#39;&#34;failover-peer&#34;&#39;)
            &gt;&gt;&gt; print(failover.to_isc())
            failover peer &#34;failover-peer&#34; {
            }

            &gt;&gt;&gt; failover.role = &#39;primary&#39;
            &gt;&gt;&gt; print(failover.to_isc())
            failover peer &#34;failover-peer&#34; {
                primary;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        space_sep = (&#39;load_balance_max_seconds&#39;)
        excluded_atts = (&#39;name&#39;)
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if key in space_sep:
                isc_key = key.replace(&#34;_&#34;, &#34; &#34;)
            else:
                isc_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if all((value, key == &#39;role&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
            elif all((value, key not in excluded_atts)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{isc_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Host(Parameters):
    &#34;&#34;&#34;Represents an host declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:               str,
        always_broadcast:   Union[bool, None] = None,
        fixed_address:      Union[str, None] = None,
        fixed_address6:     Union[str, None] = None,
        fixed_prefix6:      Union[str, None] = None,
        hardware:           Union[Hardware, None] = None,
        host_identifier:    Union[HostIdentifier, None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            always_broadcast (boolean): Broadcast even if broadcast flag is
                unset from clients.
            fixed_address (str, list[str]): One or more IPv4 address in
                string format.
            fixed_address6 (str): An IPv6 address in string format.
            fixed_prefix6 (str, list[str]): One or more IPv prefixes.
            hardware (pyisc.dhcpd.nodes.Hardware): The hardware address of
                the client.
            host_identifier (pyisc.dhcpd.nodes.HostIdentifier): IPv6
                identifier for client

        &#34;&#34;&#34;
        self.name = name
        self.always_broadcast = always_broadcast
        self.fixed_address = fixed_address
        self.fixed_address6 = fixed_address6
        self.fixed_prefix6 = fixed_prefix6
        self.hardware = hardware
        self.host_identifier = host_identifier
        super().__init__()

    def __str__(self) -&gt; str:
        return f&#39;host {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Host(name={self.name})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; host = Host(name=&#39;pluto.example.org&#39;)
            &gt;&gt;&gt; print(host.to_isc())
            host pluto.example.org {
            }

            &gt;&gt;&gt; host.always_broadcast = True
            &gt;&gt;&gt; print(host.to_isc())
            host pluto.example.org {
                always-broadcast true;
            }

            &gt;&gt;&gt; hardware = Hardware(type=&#39;ethernet&#39;, address=&#39;1234:5678:9abc&#39;)
            &gt;&gt;&gt; host.hardware = hardware
            &gt;&gt;&gt; print(host.to_isc())
            host pluto.example.org {
                always-broadcast true;
                hardware ethernet 1234:5678:9abc;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if hasattr(value, &#39;to_isc&#39;):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif isinstance(value, bool):
                attrs.append(
                    f&#39;{&#34; &#34; * child_indent}{new_key} {str(value).lower()};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Include:
    &#34;&#34;&#34;Represents the include declaration.&#34;&#34;&#34;
    def __init__(self, filename: str) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            filename (str): A path to the file that is to be included.

        &#34;&#34;&#34;
        self.filename = filename

    def __str__(self) -&gt; str:
        return f&#39;include {self.filename}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Include(filename={self.filename})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; include = Include(filename=&#39;/etc/dhcpd-keys.conf&#39;)
            &gt;&gt;&gt; print(include.to_isc())
            include /etc/dhcpd-keys.conf;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class Key:
    &#34;&#34;&#34;Represents an key declaration and parameter.&#34;&#34;&#34;
    def __init__(
        self,
        name:       str,
        algorithm:  Union[str, None] = None,
        secret:     Union[str, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the key instance.
            algorithm (str): The algorithm used for the key.
            secret (str): The secret used by the key.

        &#34;&#34;&#34;
        self.name = name
        self.algorithm = algorithm
        self.secret = secret

    def __str__(self) -&gt; str:
        return f&#39;key {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Key(name=&#34;{self.name}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        &gt;&gt;&gt; key = Key(name=&#39;DHCP_UPDATER&#39;)
        &gt;&gt;&gt; print(key.to_isc())
        key DHCP_UPDATER {
        }

        &gt;&gt;&gt; key.secret = &#39;Ofakekeyfakekeyfakekey==&#39;
        &gt;&gt;&gt; print(key.to_isc())
        key DHCP_UPDATER {
            secret Ofakekeyfakekeyfakekey==;
        }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Prefix6:
    &#34;&#34;&#34;Represents an prefix declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        start:  str,
        end:    str,
        bits:   str
    ) -&gt; None:
        self.start = start
        self.end = end
        self.bits = bits

    def __str__(self) -&gt; str:
        return f&#39;prefix6 {self.start} {self.end} {self.bits}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Prefix6(start={self.start}, end={self.end}, bits={self.bits})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; prefix = Prefix6(start=&#39;2001:db8:0:100::&#39;, end=&#39;2001:db8:0:f00::&#39;, bits=&#39;/56&#39;)
            &gt;&gt;&gt; print(prefix.to_isc())
            prefix6 2001:db8:0:100:: 2001:db8:0:f00:: /56;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class Range4:
    &#34;&#34;&#34;Represents the range declaration for IPv4 objects.&#34;&#34;&#34;
    def __init__(
        self,
        start:          str,
        end:            Union[str, None] = None,
        dynamic_bootp:  bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            start (str): The first or lowest IP address in the range.
            end (str): The last or highest IP address in the range.
            dynamic_bootp (boolean): If set allows BOOTP clients to get
                dynamically assigned addresses.

        &#34;&#34;&#34;
        self.start = start
        self.end = end
        self.dynamic_bootp = dynamic_bootp

    def __str__(self) -&gt; str:
        list_comp = [data for data in (self.start, self.end) if data]
        if self.dynamic_bootp:
            return f&#39;range dynamic-bootp {&#34; &#34;.join(list_comp)}&#39;
        else:
            return f&#39;range {&#34; &#34;.join(list_comp)}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;Range4(start={self.start}, end={self.end}, &#39;
                f&#39;dynamic_bootp={self.dynamic_bootp})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;)
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range 10.10.10.10;

            &gt;&gt;&gt; dhcp_range.end = &#39;10.10.10.250&#39;
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range 10.10.10.10 10.10.10.250;

            &gt;&gt;&gt; dhcp_range.dynamic_bootp = True
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range dynamic-bootp 10.10.10.10 10.10.10.250;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class Range6:
    &#34;&#34;&#34;Represents the range declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        start:      str,
        end:        Union[str, None] = None,
        temporary:  bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            start (str): The first or lowest IP address in the range or the
                subnet. This could also be set as a prefix in cidr notation. 
                And if so the end attribute should be omitted.
            end (str): The last or highest IP address in the range.
            temporary (boolean): If set makes the prefix available for
                temporary (RFC 4941) addresses.

        &#34;&#34;&#34;
        self.start = start
        self.end = end
        self.temporary = temporary

    def __str__(self) -&gt; str:
        list_comp = [data for data in (self.start, self.end) if data]
        if self.temporary:
            return f&#39;range6 {&#34; &#34;.join(list_comp)} temporary&#39;
        else:
            return f&#39;range6 {&#34; &#34;.join(list_comp)}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;Range6(start={self.start}, end={self.end}, &#39;
                f&#39;temporary={self.temporary})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; dhcp_range = Range6(start=&#39;dead:beef::1&#39;)
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef::1;

            &gt;&gt;&gt; dhcp_range.end = &#39;dead:beef::128&#39;
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef::1 dead:beef::128;

            &gt;&gt;&gt; dhcp_range.temporary = True
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef::1 dead:beef::128 temporary;

            &gt;&gt;&gt; dhcp_range = Range6(start=&#39;dead:beef:0:f1::/64&#39;)
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef:0:f1::/64;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;


class Zone:
    &#34;&#34;&#34;Represents an zone declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:       str,
        primary:    Union[str, None] = None,
        primary6:   Union[str, None] = None,
        secondary:  Union[str, None] = None,
        secondary6: Union[str, None] = None,
        key:        Union[Key, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            primary (str): The IP address of the primary server for the zone
                in string format.
            key (pyisc.dhcpd.nodes.Key): The key used to authenticate to the
                primary server.

        &#34;&#34;&#34;
        self.name = name
        self.primary = primary
        self.primary6 = primary6
        self.secondary = secondary
        self.secondary6 = secondary6
        self.key = key

    def __str__(self) -&gt; str:
        return f&#39;zone {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Zone(name={self.name})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; zone = Zone(name=&#39;EXAMPLE.ORG.&#39;)
            &gt;&gt;&gt; print(zone.to_isc())
            zone EXAMPLE.ORG. {
            }

            &gt;&gt;&gt; zone.primary = &#39;127.0.0.1&#39;
            &gt;&gt;&gt; print(zone.to_isc())
            zone EXAMPLE.ORG. {
                primary 127.0.0.1;
            }

            &gt;&gt;&gt; zone.key = Key(name=&#39;DHCP_UPDATER&#39;)
            &gt;&gt;&gt; print(zone.to_isc())
            zone EXAMPLE.ORG. {
                primary 127.0.0.1;
                key DHCP_UPDATER;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if all((value, key != &#39;name&#39;, key != &#39;key&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        if self.key:
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Pool4(RangeMixin):
    &#34;&#34;&#34;Represents an pool declaration for IPv4 objects.&#34;&#34;&#34;
    def __init__(
        self,
        known_clients:               Union[str, None] = None,
        unknown_clients:             Union[str, None] = None,
        allow_members_of:            Union[List[str], None] = None,
        deny_members_of:             Union[List[str], None] = None,
        dynamic_bootp_clients:       Union[str, None] = None,
        authenticated_clients:       Union[str, None] = None,
        unauthenticated_clients:     Union[str, None] = None,
        all_clients:                 Union[str, None] = None,
        allow_after:                 Union[int, None] = None,
        deny_after:                  Union[int, None] = None,
        failover:                    Union[Failover, None] = None,
        ranges:                      Union[List[Range4], None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            known_clients (str): Allows or denies known clients.
            unknown_clients (str): Allows or denies unknown clients.
            allow_members_of (list[str]): List of allowed classes.
            deny_members_of (list[str]): List of denied classes.
            dynamic_bootp_clients (str): Allows or denies bootp clients.
            authenticated_clients (str): Allows or denies authenticated
                clients.
            unauthenticated_clients (str): Allows or denies unauthenticated
                clients.
            all_clients (str): Allows or denies all clients.
            allow_after (int): Allows clients after a given date.
            deny_after (int): Denies clients after a given date.
            failover (pyisc.dhcpd.nodes.Failover): The failover peer of the
                pool.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of IPv4 ranges
                belonging to the pool.

        &#34;&#34;&#34;
        self.known_clients = known_clients
        self.unknown_clients = unknown_clients
        self.allow_members_of = [] if not allow_members_of else allow_members_of
        self.deny_members_of = [] if not deny_members_of else deny_members_of
        self.dynamic_bootp_clients = dynamic_bootp_clients
        self.authenticated_clients = authenticated_clients
        self.unauthenticated_clients = unauthenticated_clients
        self.all_clients = all_clients
        self.allow_after = allow_after
        self.deny_after = deny_after
        self.failover = failover
        self.ranges = [] if not ranges else ranges

    def __str__(self) -&gt; str:
        return &#39;pool&#39;

    def __repr__(self) -&gt; str:
        return &#39;Pool4()&#39;

    def add_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.append(member)

    def delete_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.remove(member)

    def add_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.append(member)

    def delete_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.remove(member)

    def object_tree(self, indent=0):
        attrs = []
        child_indent = indent+4
        for dhcp_range in self.ranges:
            attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.object_tree()}&#39;)
        return_str = f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        return f&#39;{return_str}{attrs_str}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
            }

            &gt;&gt;&gt; pool.known_clients = &#39;allow&#39;
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
            }

            &gt;&gt;&gt; pool.unknown_clients = &#39;deny&#39;
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
            }

            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
                allow members of &#34;foo&#34;;
            }

            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;bar&#34;&#39;)
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
                allow members of &#34;foo&#34;;
                allow members of &#34;bar&#34;;
            }

            &gt;&gt;&gt; pool.delete_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
                allow members of &#34;bar&#34;;
            }

            &gt;&gt;&gt; failover = Failover(name=&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; pool.failover = failover
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                allow members of &#34;foo&#34;;
                failover peer &#34;foo&#34;;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if &#39;known&#39; in key:
                new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            else:
                new_key = key.replace(&#34;_&#34;, &#34; &#34;)
            if all((value, &#39;members_of&#39; in key)):
                for subvalue in value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {subvalue};&#39;)
            elif all((value, key == &#39;ranges&#39;)):
                for dhcp_range in self.ranges:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.to_isc()}&#39;)
            elif all((value, key == &#39;failover&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
            elif any((value == &#39;allow&#39;, value == &#39;deny&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value} {new_key};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


# Untested
class Pool6:
    &#34;&#34;&#34;Represents an pool declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        known_clients:              Union[str, None] = None,
        unknown_clients:            Union[str, None] = None,
        allow_members_of:           Union[List[str], None] = None,
        deny_members_of:            Union[List[str], None] = None,
        dynamic_bootp_clients:      Union[str, None] = None,
        authenticated_clients:      Union[str, None] = None,
        unauthenticated_clients:    Union[str, None] = None,
        all_clients:                Union[str, None] = None,
        allow_after:                Union[int, None] = None,
        deny_after:                 Union[int, None] = None,
        failover:                   Union[Failover, None] = None,
        ranges:                     Union[List[Range6], None] = None,
        prefix6:                    Union[Prefix6, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            known_clients (str): Allows or denies known clients.
            unknown_clients (str): Allows or denies unknown clients.
            allow_members_of (list[str]): List of allowed classes.
            deny_members_of (list[str]): List of denied classes.
            dynamic_bootp_clients (str): Allows or denies bootp clients.
            authenticated_clients (str): Allows or denies authenticated
                clients.
            unauthenticated_clients (str): Allows or denies unauthenticated
                clients.
            all_clients (str): Allows or denies all clients.
            allow_after (int): Allows clients after a given date.
            deny_after (int): Denies clients after a given date.
            failover (pyisc.dhcpd.nodes.Failover): The failover peer of the
                pool.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of IPv4 ranges
                belonging to the pool.

        &#34;&#34;&#34;
        self.known_clients = known_clients
        self.unknown_clients = unknown_clients
        self.allow_members_of = [] if not allow_members_of else allow_members_of
        self.deny_members_of = [] if not deny_members_of else deny_members_of
        self.dynamic_bootp_clients = dynamic_bootp_clients
        self.authenticated_clients = authenticated_clients
        self.unauthenticated_clients = unauthenticated_clients
        self.all_clients = all_clients
        self.allow_after = allow_after
        self.deny_after = deny_after
        self.failover = failover
        self.ranges = [] if not ranges else ranges
        self.prefix6 = prefix6

    def __str__(self) -&gt; str:
        return &#39;pool&#39;

    def __repr__(self) -&gt; str:
        return &#39;Pool4()&#39;

    def add_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.append(member)

    def delete_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.remove(member)

    def add_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.append(member)

    def delete_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.remove(member)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if &#39;known&#39; in key:
                new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            else:
                new_key = key.replace(&#34;_&#34;, &#34; &#34;)
            if all((value, &#39;members_of&#39; in key)):
                for subvalue in value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {subvalue};&#39;)
            elif all((value, key == &#39;ranges&#39;)):
                for dhcp_range in self.ranges:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.to_isc()}&#39;)
            # elif all((value, key == &#39;prefix6&#39;)):
            #     attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif hasattr(value, &#39;to_isc&#39;):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif all((value, key == &#39;failover&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
            elif any((value == &#39;allow&#39;, value == &#39;deny&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value} {new_key};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class SubClass(Parameters, OptionMixin):
    &#34;&#34;&#34;Represents an subclass declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:           str,
        match_value:    str,
        lease_limit:    Union[int, None] = None,
        options:        Union[List[Option], None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            match_value (str): The conditional in the form of a string.
            lease_limit (int): Sets the amount of clients that are allowed a
                lease.
            options (list[pyisc.dhcpd.nodes.Option]): A list of options.

        &#34;&#34;&#34;
        self.name = name
        self.match_value = match_value
        self.lease_limit = lease_limit
        self.options = [] if not options else options
        super().__init__()

    def __str__(self) -&gt; str:
        return f&#39;subclass {self.name} {self.match_value}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;SubClass(name={self.name}, match_value={self.match_value})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; subclass = SubClass(name=&#39;&#34;foo&#34;&#39;,
                                    match_value=&#39;1:08:00:2b:a1:11:31&#39;)
            &gt;&gt;&gt; print(subclass.to_isc())
            subclass &#34;foo&#34; 1:08:00:2b:a1:11:31;

            &gt;&gt;&gt; subclass.lease_limit = 4
            &gt;&gt;&gt; print(subclass.to_isc())
            subclass &#34;foo&#34; 1:08:00:2b:a1:11:31 {
                lease limit 4;
            }

            &gt;&gt;&gt; option = Option(name=&#39;domain-name-servers&#39;,
                                value=&#39;ns1.example.org, ns2.example.org&#39;)
            &gt;&gt;&gt; subclass.add_option(option)
            &gt;&gt;&gt; print(subclass.to_isc())
            subclass &#34;foo&#34; 1:08:00:2b:a1:11:31 {
                lease limit 4;
                option domain-name-servers ns1.example.org, ns2.example.org;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if key == &#39;lease_limit&#39;:
                new_key = key.replace(&#34;_&#34;, &#34; &#34;)
            else:
                new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((value, key != &#39;name&#39;, key != &#39;match_value&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        if len(attrs) == 0:
            return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39; &#39;\n&#39;)
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Subnet4(Parameters, Permissions, OptionMixin, RangeMixin, PoolMixin):
    &#34;&#34;&#34;Represents an subnet declaration for IPv4 objects.&#34;&#34;&#34;
    def __init__(
        self,
        network:            str,
        authoritative:      Union[bool, None] = None,
        server_id_check:    Union[bool, None] = None,
        options:            Union[List[Option], None] = None,
        ranges:             Union[List[Range4], None] = None,
        pools:              Union[List[Pool4], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            network (str): The network in CIDR format.
            authoritative (boolean): Authoritative state.
            server_id_check (boolean): Tells the server to verify value of
                dhcp-server-identifier option.
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of ranges.
            pools (list[pyisc.dhcpd.nodes.Pool4]): List of pools.

        &#34;&#34;&#34;
        self.network = IPv4Network(network).with_prefixlen
        self.authoritative = authoritative
        self.server_id_check = server_id_check
        self.options = [] if not options else options
        self.ranges = [] if not ranges else ranges
        self.pools = [] if not pools else pools
        super().__init__()

    # def __lt__(self, other: object) -&gt; bool:
    #     return IPv4Network(self.network) &lt; IPv4Network(other.network)

    # def __eq__(self, other: object) -&gt; bool:
    #     if other is None:
    #         return False
    #     return (
    #         IPv4Network(self.network) == IPv4Network(other.network)
    #     )

    def __str__(self) -&gt; str:
        ip_network = IPv4Network(self.network)
        subnet, netmask = ip_network.with_netmask.split(&#39;/&#39;)
        return f&#39;subnet {subnet} netmask {netmask}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Subnet4(network=&#34;{self.network}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
            }

            &gt;&gt;&gt; subnet.authoritative = True
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
                authoritative;
            }

            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; pool.known_clients = &#39;allow&#39;
            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; subnet.add_pool(pool)
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
                authoritative;
                pool {
                    allow known-clients;
                    allow members of &#34;foo&#34;;
                }
            }

            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; subnet.add_option(option)
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
                authoritative;
                option domain-name &#34;example.org&#34;;
                pool {
                    allow known-clients;
                    allow members of &#34;foo&#34;;
                }
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{key};&#39;)
                else:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}not {key};&#39;)
            elif all((value, key != &#39;network&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


# Untested
class Subnet6(Parameters, Permissions, OptionMixin, RangeMixin, PoolMixin):
    &#34;&#34;&#34;Represents an subnet declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        network:            str,
        authoritative:      Union[bool, None] = None,
        server_id_check:    Union[bool, None] = None,
        options:            Union[List[Option], None] = None,
        ranges:             Union[List[Range6], None] = None,
        pools:              Union[List[Pool6], None] = None,
        prefix6:            Union[Prefix6, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            network (str): The network in CIDR format.
            authoritative (boolean): Authoritative state.
            server_id_check (boolean): Tells the server to verify value of
                dhcp-server-identifier option.
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of ranges.
            pools (list[pyisc.dhcpd.nodes.Pool4]): List of pools.

        &#34;&#34;&#34;
        self.network = IPv6Network(network).with_prefixlen
        self.authoritative = authoritative
        self.server_id_check = server_id_check
        self.options = [] if not options else options
        self.ranges = [] if not ranges else ranges
        self.pools = [] if not pools else pools
        self.prefix6 = prefix6
        super().__init__()

    # def __lt__(self, other: object) -&gt; bool:
    #     return IPv6Network(self.network) &lt; IPv6Network(other.network)

    # def __eq__(self, other: object) -&gt; bool:
    #     if other is None:
    #         return False
    #     return (
    #         IPv6Network(self.network) == IPv6Network(other.network)
    #     )

    def __str__(self) -&gt; str:
        return f&#39;subnet6 {self.network}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Subnet6(network=&#34;{self.network}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; pass

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif hasattr(value, &#39;to_isc&#39;):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{key};&#39;)
                else:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}not {key};&#39;)
            elif all((value, key != &#39;network&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class SharedNetwork(Parameters, Permissions, OptionMixin, SubnetMixin,
                    PoolMixin):
    &#34;&#34;&#34;Represents an shared network declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:           str,
        authoritative:  Union[bool, None] = None,
        options:        Union[List[Option], None] = None,
        subnets:        Union[List[Subnet4], None] = None,
        pools:          Union[List[Pool4], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): Name of the Shared Network.
            authoritative (boolean): Authoritative state.
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of ranges.
            pools (list[pyisc.dhcpd.nodes.Pool4]): List of pools.

        &#34;&#34;&#34;
        self.name = name
        self.authoritative = authoritative
        self.options = [] if not options else options
        self.subnets = [] if not subnets else subnets
        self.pools = [] if not pools else pools

    def __str__(self) -&gt; str:
        return f&#39;shared-network {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;SharedNetwork(name={self.name})&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; shared_network = SharedNetwork(name=&#39;&#34;test&#34;&#39;)
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
            }

            &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
            &gt;&gt;&gt; shared_network.add_subnet(subnet)
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
            }

            &gt;&gt;&gt; shared_network.authoritative = True
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
            authoritative;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
            }

            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;, end=&#39;10.10.10.250&#39;)
            &gt;&gt;&gt; pool.add_range(dhcp_range)
            &gt;&gt;&gt; shared_network.add_pool(pool)
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
            authoritative;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
                pool {
                    allow members of &#34;foo&#34;;
                    range 10.10.10.10 10.10.10.250;
                }
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{key};&#39;)
                else:
                    attrs.append(f&#39;not {key};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Group(Parameters, SubnetMixin, SharedNetworkMixin, HostMixin,
            OptionMixin):
    &#34;&#34;&#34;Represents an group declaration.&#34;&#34;&#34;
    def __init__(
        self,
        options:            Union[List[Option], None] = None,
        subnets:            Union[List[Subnet4], None] = None,
        shared_networks:    Union[List[SharedNetwork], None] = None,
        hosts:              Union[List[Host], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            subnets (list[pyisc.dhcpd.nodes.Subnet4]): List of subnets.
            shared_networks (list[pyisc.dhcpd.nodes.SharedNetwork]): List of
                shared networks.
            hosts (list[pyisc.dhcpd.nodes.Host]): List of hosts.

        &#34;&#34;&#34;
        self.options = [] if not options else options
        self.subnets = [] if not subnets else subnets
        self.shared_networks = [] if not shared_networks else shared_networks
        # self.groups = [] if not groups else groups
        self.hosts = [] if not hosts else hosts

    def __str__(self) -&gt; str:
        return &#39;group&#39;

    def __repr__(self) -&gt; str:
        return &#39;Group()&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; group = Group()
            &gt;&gt;&gt; print(group.to_isc())
            group {
            }

            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; group.add_option(option)
            &gt;&gt;&gt; print(group.to_isc())
            group {
                option domain-name &#34;example.org&#34;;
            }

            &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
            &gt;&gt;&gt; group.add_subnet(subnet)
            &gt;&gt;&gt; print(group.to_isc())
            group {
                option domain-name &#34;example.org&#34;;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
            }

            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; pool.unknown_clients = &#39;deny&#39;
            &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;, end=&#39;10.10.10.250&#39;)
            &gt;&gt;&gt; pool.add_range(dhcp_range)
            &gt;&gt;&gt; subnet.add_pool(pool)
            &gt;&gt;&gt; print(group.to_isc())
            group {
                option domain-name &#34;example.org&#34;;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                    pool {
                        deny unknown-clients;
                        range 10.10.10.10 10.10.10.250;
                    }
                }
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif value:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)


class Global(Parameters, Permissions, OptionMixin, SubnetMixin,
             SharedNetworkMixin, GroupMixin, HostMixin, ClassMixin,
             SubClassMixin, KeyMixin, ZoneMixin, IncludeMixin, EventMixin):
    &#34;&#34;&#34;Represents the global dhcp server settings.&#34;&#34;&#34;
    def __init__(
        self,
        abandon_lease_time:             Union[str, None] = None,
        authoritative:                  Union[bool, None] = None,
        db_time_format:                 Union[str, None] = None,
        ddns_dual_stack_mixed_mode:     Union[str, None] = None,
        ddns_guard_id_must_match:       Union[str, None] = None,
        ddns_other_guard_is_dynamic:    Union[str, None] = None,
        lease_file_name:                Union[str, None] = None,
        dhcpv6_lease_file_name:         Union[str, None] = None,
        local_port:                     Union[int, None] = None,
        local_address:                  Union[str, None] = None,
        local_address6:                 Union[str, None] = None,
        bind_local_address6:            Union[bool, None] = None,
        log_facility:                   Union[str, None] = None,
        omapi_port:                     Union[int, None] = None,
        omapi_key:                      Union[str, None] = None,
        persist_eui_64_leases:          Union[bool, None] = None,
        pid_file_name:                  Union[str, None] = None,
        dhcpv6_pid_file_name:           Union[str, None] = None,
        release_on_roam:                Union[bool, None] = None,
        remote_port:                    Union[int, None] = None,
        server_id_check:                Union[bool, None] = None,
        server_duid:                    Union[ServerDuidEN, ServerDuidLL, None] = None,
        update_conflict_detection:      Union[bool, None] = None,
        use_eui_64:                     Union[bool, None] = None,
        options:                        Union[List[Option], None] = None,
        keys:                           Union[List[Key], None] = None,
        zones:                          Union[List[Zone], None] = None,
        failover:                       Union[Failover, None] = None,
        subnets:                        Union[List[Subnet4], None] = None,
        shared_networks:                Union[List[SharedNetwork], None] = None,
        groups:                         Union[List[Group], None] = None,
        hosts:                          Union[List[Host], None] = None,
        classes:                        Union[List[DhcpClass], None] = None,
        subclasses:                     Union[List[SubClass], None] = None,
        includes:                       Union[List[Include], None] = None,
        events:                         Union[List[Event], None] = None,
        custom_options:                 Union[List[CustomOption], None] = None,
        option_expressions:             Union[List[OptionExpression], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            abandon_lease_time (str): pass
            authoritative (boolean): pass
            db_time_format (str): pass
            ddns_dual_stack_mixed_mode (str): pass

        &#34;&#34;&#34;
        self.abandon_lease_time = abandon_lease_time
        self.authoritative = authoritative
        self.db_time_format = db_time_format
        self.ddns_dual_stack_mixed_mode = ddns_dual_stack_mixed_mode
        self.ddns_guard_id_must_match = ddns_guard_id_must_match
        self.ddns_other_guard_is_dynamic = ddns_other_guard_is_dynamic
        self.lease_file_name = lease_file_name
        self.dhcpv6_lease_file_name = dhcpv6_lease_file_name
        self.local_port = local_port
        self.local_address = local_address
        self.local_address6 = local_address6
        self.bind_local_address6 = bind_local_address6
        self.log_facility = log_facility
        self.omapi_port = omapi_port
        self.omapi_key = omapi_key
        self.pid_file_name = pid_file_name
        self.dhcpv6_pid_file_name = dhcpv6_pid_file_name
        self.release_on_roam = release_on_roam
        self.remote_port = remote_port
        self.server_id_check = server_id_check
        self.server_duid = server_duid
        self.update_conflict_detection = update_conflict_detection
        self.use_eui_64 = use_eui_64
        self.persist_eui_64_leases = persist_eui_64_leases
        self.options = [] if not options else options
        self.keys = [] if not keys else keys
        self.zones = [] if not zones else zones
        self.failover = failover
        self.subnets = [] if not subnets else subnets
        self.shared_networks = [] if not shared_networks else shared_networks
        self.groups = [] if not groups else groups
        self.hosts = [] if not hosts else hosts
        self.classes = [] if not classes else classes
        self.subclasses = [] if not subclasses else subclasses
        self.includes = [] if not includes else includes
        self.events = [] if not events else events
        self.custom_options = [] if not custom_options else custom_options
        self.option_expressions = [] if not option_expressions else \
            option_expressions
        super().__init__()

    def __str__(self) -&gt; str:
        return &#39;Global&#39;

    def __repr__(self) -&gt; str:
        return &#39;Global()&#39;

    def add_custom_option(self, option: CustomOption):
        self.custom_options.append(option)

    def find_custom_option(self, option):
        pass

    def delete_custom_option(self, option):
        pass

    def add_option_expression(self, option: OptionExpression):
        self.option_expressions.append(option)

    def find_option_expression(self, option):
        pass

    def delete_option_expression(self, option):
        pass

    def to_isc(self):
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        sort_order = {
            &#39;options&#39;: 1,
            &#39;includes&#39;: 2,
            &#39;custom_options&#39;: 3,
            &#39;option_expressions&#39;: 4,
            &#39;keys&#39;: 5,
            &#39;zones&#39;: 6,
            &#39;failover&#39;: 7,
            &#39;subnets&#39;: 8,
            &#39;shared_networks&#39;: 9,
            &#39;classes&#39;: 10,
            &#39;subclasses&#39;: 11,
            &#39;hosts&#39;: 12,
            &#39;groups&#39;: 13,
            &#39;events&#39;: 14
            }
        sorted_dict = sorted(
            self.__dict__.items(), key=lambda x: sort_order.get(x[0], 0))
        for key, value in sorted_dict:
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if value and key == &#39;failover&#39;:
                attrs.append(value.to_isc())
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{key};&#39;)
                else:
                    attrs.append(f&#39;not {key};&#39;)
            elif isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc())
            elif isinstance(value, bool):
                attrs.append(f&#39;{new_key} {str(value).lower()};&#39;)
            elif value in (&#39;deny&#39;, &#39;allow&#39;, &#39;ignore&#39;):
                attrs.append(f&#39;{value} {new_key};&#39;)
            elif value:
                attrs.append(f&#39;{new_key} {value};&#39;)
        attrs_str = &#34;\n&#34;.join(attrs)
        return (f&#39;{attrs_str}&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyisc.dhcpd.nodes.CustomOption"><code class="flex name class">
<span>class <span class="ident">CustomOption</span></span>
<span>(</span><span>name:str, code:int, definition:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an custom dhcp option definition.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the dhcp option.</dd>
<dt><strong><code>code</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of the dhcp option.</dd>
<dt><strong><code>definition</code></strong> :&ensp;<code>str</code></dt>
<dd>The definition of the option.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomOption:
    &#34;&#34;&#34;Represents an custom dhcp option definition.&#34;&#34;&#34;
    def __init__(
        self,
        name:       str,
        code:       int,
        definition: str
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the dhcp option.
            code (int): The number of the dhcp option.
            definition (str): The definition of the option.

        &#34;&#34;&#34;
        self.name = name
        self.code = code
        self.definition = definition

    def __str__(self) -&gt; str:
        return f&#39;option {self.name} code {self.code} = {self.definition}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;CustomOption(name={self.name}, code={self.code}, &#39;
                f&#39;definition={self.definition})&#39;)

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; new_option = CustomOption(name=&#39;client-arch-type&#39;, code=93,
                                          definition=&#39;unsigned integer 16&#39;)
            &gt;&gt;&gt; print(new_option.to_isc())
            option client-arch-type code 93 = unsigned integer 16;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.CustomOption.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; new_option = CustomOption(name='client-arch-type', code=93,
                              definition='unsigned integer 16')
&gt;&gt;&gt; print(new_option.to_isc())
option client-arch-type code 93 = unsigned integer 16;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; new_option = CustomOption(name=&#39;client-arch-type&#39;, code=93,
                                      definition=&#39;unsigned integer 16&#39;)
        &gt;&gt;&gt; print(new_option.to_isc())
        option client-arch-type code 93 = unsigned integer 16;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.DhcpClass"><code class="flex name class">
<span>class <span class="ident">DhcpClass</span></span>
<span>(</span><span>name:str, always_broadcast:Union[bool,NoneType]=None, match:Union[str,NoneType]=None, spawn:Union[str,NoneType]=None, lease_limit:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an class declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the zone.</dd>
<dt><strong><code>always_broadcast</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Broadcast even if broadcast flag is
unset from clients.</dd>
<dt><strong><code>match</code></strong> :&ensp;<code>str</code></dt>
<dd>The conditional in the form of a string.</dd>
<dt><strong><code>spawn</code></strong> :&ensp;<code>str</code></dt>
<dd>The spawn argument in the form of a string.</dd>
<dt><strong><code>lease_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets the amount of clients that are allowed a
lease</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DhcpClass:
    &#34;&#34;&#34;Represents an class declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:               str,
        always_broadcast:   Union[bool, None] = None,
        match:              Union[str, None] = None,
        spawn:              Union[str, None] = None,
        lease_limit:        Union[int, None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            always_broadcast (boolean): Broadcast even if broadcast flag is
                unset from clients.
            match (str): The conditional in the form of a string.
            spawn (str): The spawn argument in the form of a string.
            lease_limit (int): Sets the amount of clients that are allowed a
                lease

        &#34;&#34;&#34;
        self.name = name
        self.always_broadcast = always_broadcast
        self.match = match
        self.spawn = spawn
        self.lease_limit = lease_limit

    def __str__(self) -&gt; str:
        return f&#39;class {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;DhcpClass(name={self.name})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; dhcp_class = DhcpClass(name=&#39;foo&#39;)
            &gt;&gt;&gt; print(dhcp_class.to_isc())
            class foo {
            }

            &gt;&gt;&gt; dhcp_class.lease_limit = 4
            &gt;&gt;&gt; print(dhcp_class.to_isc())
            class foo {
                lease limit 4;
            }

            &gt;&gt;&gt; dhcp_class.match = &#39;if substring (option vendor-class-identifier, 0, 4) = &#34;SUNW&#34;&#39;
            &gt;&gt;&gt; print(dhcp_class.to_isc())
            class foo {
                match if substring (option vendor-class-identifier, 0, 4) = &#34;SUNW&#34;;
                lease limit 4;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        space_sep = (&#39;lease_limit&#39;)
        excluded_atts = (&#39;name&#39;)
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if key in space_sep:
                isc_key = key.replace(&#34;_&#34;, &#34; &#34;)
            else:
                isc_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if all((value, key not in excluded_atts)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{isc_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.DhcpClass.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.DhcpClass.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_class = DhcpClass(name='foo')
&gt;&gt;&gt; print(dhcp_class.to_isc())
class foo {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_class.lease_limit = 4
&gt;&gt;&gt; print(dhcp_class.to_isc())
class foo {
    lease limit 4;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_class.match = 'if substring (option vendor-class-identifier, 0, 4) = &quot;SUNW&quot;'
&gt;&gt;&gt; print(dhcp_class.to_isc())
class foo {
    match if substring (option vendor-class-identifier, 0, 4) = &quot;SUNW&quot;;
    lease limit 4;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; dhcp_class = DhcpClass(name=&#39;foo&#39;)
        &gt;&gt;&gt; print(dhcp_class.to_isc())
        class foo {
        }

        &gt;&gt;&gt; dhcp_class.lease_limit = 4
        &gt;&gt;&gt; print(dhcp_class.to_isc())
        class foo {
            lease limit 4;
        }

        &gt;&gt;&gt; dhcp_class.match = &#39;if substring (option vendor-class-identifier, 0, 4) = &#34;SUNW&#34;&#39;
        &gt;&gt;&gt; print(dhcp_class.to_isc())
        class foo {
            match if substring (option vendor-class-identifier, 0, 4) = &#34;SUNW&#34;;
            lease limit 4;
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    space_sep = (&#39;lease_limit&#39;)
    excluded_atts = (&#39;name&#39;)
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if key in space_sep:
            isc_key = key.replace(&#34;_&#34;, &#34; &#34;)
        else:
            isc_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        if all((value, key not in excluded_atts)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{isc_key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Event"><code class="flex name class">
<span>class <span class="ident">Event</span></span>
<span>(</span><span>event_type:str, event_sets:Union[List[<a title="pyisc.dhcpd.nodes.EventSet" href="#pyisc.dhcpd.nodes.EventSet">EventSet</a>],NoneType]=None, execute:Union[str,NoneType]=None, log:Union[str,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the event declaration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Event(EventSetMixin):
    &#34;&#34;&#34;Represents the event declaration.&#34;&#34;&#34;
    def __init__(
        self,
        event_type: str,
        event_sets: Union[List[EventSet], None] = None,
        execute:    Union[str, None] = None,
        log:        Union[str, None] = None
    ) -&gt; None:
        self.event_type = event_type
        self.event_sets = [] if not event_sets else event_sets
        self.execute = execute
        self.log = log

    def __str__(self) -&gt; str:
        return f&#39;on {self.event_type}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Event(event_type={self.event_type})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; event = Event(event_type=&#39;commit&#39;)
            &gt;&gt;&gt; print(event.to_isc())
            on commit {
            }

            &gt;&gt;&gt; event.add_event_set(
                EventSet(key=&#39;clip&#39;,
                    value=&#39;binary-to-ascii(10, 8, &#34;.&#34;, leased-address)&#39;))
            &gt;&gt;&gt; print(event.to_isc())
            on commit {
                set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);
            }

            &gt;&gt;&gt; event.execute = &#39;(&#34;/usr/local/sbin/dhcpevent&#34;, &#34;commit&#34;, clip, clhw, host-decl-name)&#39;
            &gt;&gt;&gt; print(event.to_isc())
            on commit {
                set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);
                execute (&#34;/usr/local/sbin/dhcpevent&#34;, &#34;commit&#34;, clip, clhw, host-decl-name);
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        excluded_atts = (&#39;event_type&#39;)
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((value, key not in excluded_atts)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.EventSetMixin" href="mixin.html#pyisc.dhcpd.mixin.EventSetMixin">EventSetMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Event.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Event.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; event = Event(event_type='commit')
&gt;&gt;&gt; print(event.to_isc())
on commit {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; event.add_event_set(
    EventSet(key='clip',
        value='binary-to-ascii(10, 8, &quot;.&quot;, leased-address)'))
&gt;&gt;&gt; print(event.to_isc())
on commit {
    set clip = binary-to-ascii(10, 8, &quot;.&quot;, leased-address);
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; event.execute = '(&quot;/usr/local/sbin/dhcpevent&quot;, &quot;commit&quot;, clip, clhw, host-decl-name)'
&gt;&gt;&gt; print(event.to_isc())
on commit {
    set clip = binary-to-ascii(10, 8, &quot;.&quot;, leased-address);
    execute (&quot;/usr/local/sbin/dhcpevent&quot;, &quot;commit&quot;, clip, clhw, host-decl-name);
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; event = Event(event_type=&#39;commit&#39;)
        &gt;&gt;&gt; print(event.to_isc())
        on commit {
        }

        &gt;&gt;&gt; event.add_event_set(
            EventSet(key=&#39;clip&#39;,
                value=&#39;binary-to-ascii(10, 8, &#34;.&#34;, leased-address)&#39;))
        &gt;&gt;&gt; print(event.to_isc())
        on commit {
            set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);
        }

        &gt;&gt;&gt; event.execute = &#39;(&#34;/usr/local/sbin/dhcpevent&#34;, &#34;commit&#34;, clip, clhw, host-decl-name)&#39;
        &gt;&gt;&gt; print(event.to_isc())
        on commit {
            set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);
            execute (&#34;/usr/local/sbin/dhcpevent&#34;, &#34;commit&#34;, clip, clhw, host-decl-name);
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    excluded_atts = (&#39;event_type&#39;)
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc(indent=child_indent))
        elif all((value, key not in excluded_atts)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.EventSet"><code class="flex name class">
<span>class <span class="ident">EventSet</span></span>
<span>(</span><span>key:str, value:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an set expression for event objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventSet:
    &#34;&#34;&#34;Represents an set expression for event objects.&#34;&#34;&#34;
    def __init__(self, key: str, value: str) -&gt; None:
        self.key = key
        self.value = value

    def __str__(self) -&gt; str:
        return f&#39;set {self.key} = {self.value}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;EventSet(key={self.key}, value={self.value})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; event_set = EventSet(key=&#39;clip&#39;,
                        value=&#39;binary-to-ascii(10, 8, &#34;.&#34;, leased-address)&#39;)
            &gt;&gt;&gt; print(event_set.to_isc())
            set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.EventSet.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.EventSet.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; event_set = EventSet(key='clip',
            value='binary-to-ascii(10, 8, &quot;.&quot;, leased-address)')
&gt;&gt;&gt; print(event_set.to_isc())
set clip = binary-to-ascii(10, 8, &quot;.&quot;, leased-address);
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; event_set = EventSet(key=&#39;clip&#39;,
                    value=&#39;binary-to-ascii(10, 8, &#34;.&#34;, leased-address)&#39;)
        &gt;&gt;&gt; print(event_set.to_isc())
        set clip = binary-to-ascii(10, 8, &#34;.&#34;, leased-address);

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Failover"><code class="flex name class">
<span>class <span class="ident">Failover</span></span>
<span>(</span><span>name:str, role:Union[str,NoneType]=None, address:Union[str,NoneType]=None, peer_address:Union[str,NoneType]=None, port:Union[int,NoneType]=None, peer_port:Union[int,NoneType]=None, max_response_delay:Union[int,NoneType]=None, max_unacked_updates:Union[int,NoneType]=None, mclt:Union[int,NoneType]=None, split:Union[int,NoneType]=None, hba:Union[str,NoneType]=None, load_balance_max_seconds:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Failover declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>A name for the failover peer.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code>str</code></dt>
<dd>Should be either primary or secondary.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP address of the server in string format.</dd>
<dt><strong><code>peer_address</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP address of the failover peer server
in string format.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The TCP port that the server listens for connections
from failover peer.</dd>
<dt><strong><code>peer_port</code></strong> :&ensp;<code>int</code></dt>
<dd>The TCP port that the server connects to its
failover peer.</dd>
<dt><strong><code>max_response_delay</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets maximum response delay.</dd>
<dt><strong><code>max_unacked_updates</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets maximum for unacknowledged
messages.</dd>
<dt><strong><code>mclt</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets maximum client lead time.</dd>
<dt><strong><code>split</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets split load between primary and secondary
failover member.</dd>
<dt><strong><code>hba</code></strong> :&ensp;<code>str</code></dt>
<dd>Sets split load between primary and secondary
failover member as a bitmap.</dd>
<dt><strong><code>load_balance_max_seconds</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets cutoff for disabling load
balance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Failover:
    &#34;&#34;&#34;Represents the Failover declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:                       str,
        role:                       Union[str, None] = None,
        address:                    Union[str, None] = None,
        peer_address:               Union[str, None] = None,
        port:                       Union[int, None] = None,
        peer_port:                  Union[int, None] = None,
        max_response_delay:         Union[int, None] = None,
        max_unacked_updates:        Union[int, None] = None,
        mclt:                       Union[int, None] = None,
        split:                      Union[int, None] = None,
        hba:                        Union[str, None] = None,
        load_balance_max_seconds:   Union[int, None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): A name for the failover peer.
            role (str): Should be either primary or secondary.
            address (str): The IP address of the server in string format.
            peer_address (str): The IP address of the failover peer server
                in string format.
            port (int): The TCP port that the server listens for connections
                from failover peer.
            peer_port (int): The TCP port that the server connects to its
                failover peer.
            max_response_delay (int): Sets maximum response delay.
            max_unacked_updates (int): Sets maximum for unacknowledged
                messages.
            mclt (int): Sets maximum client lead time.
            split (int): Sets split load between primary and secondary
                failover member.
            hba (str): Sets split load between primary and secondary
                failover member as a bitmap.
            load_balance_max_seconds (int): Sets cutoff for disabling load
                balance.

        &#34;&#34;&#34;
        self.name = name
        self.role = role
        self.address = address
        self.peer_address = peer_address
        self.port = port
        self.peer_port = peer_port
        self.max_response_delay = max_response_delay
        self.max_unacked_updates = max_unacked_updates
        self.mclt = mclt
        self.split = split
        self.hba = hba
        self.load_balance_max_seconds = load_balance_max_seconds

    def __str__(self) -&gt; str:
        return f&#39;failover peer {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Failover(name={self.name})&#39;

    def object_tree(self, indent=0):
        &#34;&#34;&#34;TEMP.&#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; failover = Failover(name=&#39;&#34;failover-peer&#34;&#39;)
            &gt;&gt;&gt; print(failover.to_isc())
            failover peer &#34;failover-peer&#34; {
            }

            &gt;&gt;&gt; failover.role = &#39;primary&#39;
            &gt;&gt;&gt; print(failover.to_isc())
            failover peer &#34;failover-peer&#34; {
                primary;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        space_sep = (&#39;load_balance_max_seconds&#39;)
        excluded_atts = (&#39;name&#39;)
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if key in space_sep:
                isc_key = key.replace(&#34;_&#34;, &#34; &#34;)
            else:
                isc_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if all((value, key == &#39;role&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
            elif all((value, key not in excluded_atts)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{isc_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Failover.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"><p>TEMP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    &#34;&#34;&#34;TEMP.&#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Failover.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; failover = Failover(name='&quot;failover-peer&quot;')
&gt;&gt;&gt; print(failover.to_isc())
failover peer &quot;failover-peer&quot; {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; failover.role = 'primary'
&gt;&gt;&gt; print(failover.to_isc())
failover peer &quot;failover-peer&quot; {
    primary;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; failover = Failover(name=&#39;&#34;failover-peer&#34;&#39;)
        &gt;&gt;&gt; print(failover.to_isc())
        failover peer &#34;failover-peer&#34; {
        }

        &gt;&gt;&gt; failover.role = &#39;primary&#39;
        &gt;&gt;&gt; print(failover.to_isc())
        failover peer &#34;failover-peer&#34; {
            primary;
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    space_sep = (&#39;load_balance_max_seconds&#39;)
    excluded_atts = (&#39;name&#39;)
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if key in space_sep:
            isc_key = key.replace(&#34;_&#34;, &#34; &#34;)
        else:
            isc_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        if all((value, key == &#39;role&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
        elif all((value, key not in excluded_atts)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{isc_key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Global"><code class="flex name class">
<span>class <span class="ident">Global</span></span>
<span>(</span><span>abandon_lease_time:Union[str,NoneType]=None, authoritative:Union[bool,NoneType]=None, db_time_format:Union[str,NoneType]=None, ddns_dual_stack_mixed_mode:Union[str,NoneType]=None, ddns_guard_id_must_match:Union[str,NoneType]=None, ddns_other_guard_is_dynamic:Union[str,NoneType]=None, lease_file_name:Union[str,NoneType]=None, dhcpv6_lease_file_name:Union[str,NoneType]=None, local_port:Union[int,NoneType]=None, local_address:Union[str,NoneType]=None, local_address6:Union[str,NoneType]=None, bind_local_address6:Union[bool,NoneType]=None, log_facility:Union[str,NoneType]=None, omapi_port:Union[int,NoneType]=None, omapi_key:Union[str,NoneType]=None, persist_eui_64_leases:Union[bool,NoneType]=None, pid_file_name:Union[str,NoneType]=None, dhcpv6_pid_file_name:Union[str,NoneType]=None, release_on_roam:Union[bool,NoneType]=None, remote_port:Union[int,NoneType]=None, server_id_check:Union[bool,NoneType]=None, server_duid:Union[<a title="pyisc.dhcpd.nodes.ServerDuidEN" href="#pyisc.dhcpd.nodes.ServerDuidEN">ServerDuidEN</a>,<a title="pyisc.dhcpd.nodes.ServerDuidLL" href="#pyisc.dhcpd.nodes.ServerDuidLL">ServerDuidLL</a>,NoneType]=None, update_conflict_detection:Union[bool,NoneType]=None, use_eui_64:Union[bool,NoneType]=None, options:Union[List[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>],NoneType]=None, keys:Union[List[<a title="pyisc.dhcpd.nodes.Key" href="#pyisc.dhcpd.nodes.Key">Key</a>],NoneType]=None, zones:Union[List[<a title="pyisc.dhcpd.nodes.Zone" href="#pyisc.dhcpd.nodes.Zone">Zone</a>],NoneType]=None, failover:Union[<a title="pyisc.dhcpd.nodes.Failover" href="#pyisc.dhcpd.nodes.Failover">Failover</a>,NoneType]=None, subnets:Union[List[<a title="pyisc.dhcpd.nodes.Subnet4" href="#pyisc.dhcpd.nodes.Subnet4">Subnet4</a>],NoneType]=None, shared_networks:Union[List[<a title="pyisc.dhcpd.nodes.SharedNetwork" href="#pyisc.dhcpd.nodes.SharedNetwork">SharedNetwork</a>],NoneType]=None, groups:Union[List[<a title="pyisc.dhcpd.nodes.Group" href="#pyisc.dhcpd.nodes.Group">Group</a>],NoneType]=None, hosts:Union[List[<a title="pyisc.dhcpd.nodes.Host" href="#pyisc.dhcpd.nodes.Host">Host</a>],NoneType]=None, classes:Union[List[<a title="pyisc.dhcpd.nodes.DhcpClass" href="#pyisc.dhcpd.nodes.DhcpClass">DhcpClass</a>],NoneType]=None, subclasses:Union[List[<a title="pyisc.dhcpd.nodes.SubClass" href="#pyisc.dhcpd.nodes.SubClass">SubClass</a>],NoneType]=None, includes:Union[List[<a title="pyisc.dhcpd.nodes.Include" href="#pyisc.dhcpd.nodes.Include">Include</a>],NoneType]=None, events:Union[List[<a title="pyisc.dhcpd.nodes.Event" href="#pyisc.dhcpd.nodes.Event">Event</a>],NoneType]=None, custom_options:Union[List[<a title="pyisc.dhcpd.nodes.CustomOption" href="#pyisc.dhcpd.nodes.CustomOption">CustomOption</a>],NoneType]=None, option_expressions:Union[List[<a title="pyisc.dhcpd.nodes.OptionExpression" href="#pyisc.dhcpd.nodes.OptionExpression">OptionExpression</a>],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the global dhcp server settings.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>abandon_lease_time</code></strong> :&ensp;<code>str</code></dt>
<dd>pass</dd>
<dt><strong><code>authoritative</code></strong> :&ensp;<code>boolean</code></dt>
<dd>pass</dd>
<dt><strong><code>db_time_format</code></strong> :&ensp;<code>str</code></dt>
<dd>pass</dd>
<dt><strong><code>ddns_dual_stack_mixed_mode</code></strong> :&ensp;<code>str</code></dt>
<dd>pass</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Global(Parameters, Permissions, OptionMixin, SubnetMixin,
             SharedNetworkMixin, GroupMixin, HostMixin, ClassMixin,
             SubClassMixin, KeyMixin, ZoneMixin, IncludeMixin, EventMixin):
    &#34;&#34;&#34;Represents the global dhcp server settings.&#34;&#34;&#34;
    def __init__(
        self,
        abandon_lease_time:             Union[str, None] = None,
        authoritative:                  Union[bool, None] = None,
        db_time_format:                 Union[str, None] = None,
        ddns_dual_stack_mixed_mode:     Union[str, None] = None,
        ddns_guard_id_must_match:       Union[str, None] = None,
        ddns_other_guard_is_dynamic:    Union[str, None] = None,
        lease_file_name:                Union[str, None] = None,
        dhcpv6_lease_file_name:         Union[str, None] = None,
        local_port:                     Union[int, None] = None,
        local_address:                  Union[str, None] = None,
        local_address6:                 Union[str, None] = None,
        bind_local_address6:            Union[bool, None] = None,
        log_facility:                   Union[str, None] = None,
        omapi_port:                     Union[int, None] = None,
        omapi_key:                      Union[str, None] = None,
        persist_eui_64_leases:          Union[bool, None] = None,
        pid_file_name:                  Union[str, None] = None,
        dhcpv6_pid_file_name:           Union[str, None] = None,
        release_on_roam:                Union[bool, None] = None,
        remote_port:                    Union[int, None] = None,
        server_id_check:                Union[bool, None] = None,
        server_duid:                    Union[ServerDuidEN, ServerDuidLL, None] = None,
        update_conflict_detection:      Union[bool, None] = None,
        use_eui_64:                     Union[bool, None] = None,
        options:                        Union[List[Option], None] = None,
        keys:                           Union[List[Key], None] = None,
        zones:                          Union[List[Zone], None] = None,
        failover:                       Union[Failover, None] = None,
        subnets:                        Union[List[Subnet4], None] = None,
        shared_networks:                Union[List[SharedNetwork], None] = None,
        groups:                         Union[List[Group], None] = None,
        hosts:                          Union[List[Host], None] = None,
        classes:                        Union[List[DhcpClass], None] = None,
        subclasses:                     Union[List[SubClass], None] = None,
        includes:                       Union[List[Include], None] = None,
        events:                         Union[List[Event], None] = None,
        custom_options:                 Union[List[CustomOption], None] = None,
        option_expressions:             Union[List[OptionExpression], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            abandon_lease_time (str): pass
            authoritative (boolean): pass
            db_time_format (str): pass
            ddns_dual_stack_mixed_mode (str): pass

        &#34;&#34;&#34;
        self.abandon_lease_time = abandon_lease_time
        self.authoritative = authoritative
        self.db_time_format = db_time_format
        self.ddns_dual_stack_mixed_mode = ddns_dual_stack_mixed_mode
        self.ddns_guard_id_must_match = ddns_guard_id_must_match
        self.ddns_other_guard_is_dynamic = ddns_other_guard_is_dynamic
        self.lease_file_name = lease_file_name
        self.dhcpv6_lease_file_name = dhcpv6_lease_file_name
        self.local_port = local_port
        self.local_address = local_address
        self.local_address6 = local_address6
        self.bind_local_address6 = bind_local_address6
        self.log_facility = log_facility
        self.omapi_port = omapi_port
        self.omapi_key = omapi_key
        self.pid_file_name = pid_file_name
        self.dhcpv6_pid_file_name = dhcpv6_pid_file_name
        self.release_on_roam = release_on_roam
        self.remote_port = remote_port
        self.server_id_check = server_id_check
        self.server_duid = server_duid
        self.update_conflict_detection = update_conflict_detection
        self.use_eui_64 = use_eui_64
        self.persist_eui_64_leases = persist_eui_64_leases
        self.options = [] if not options else options
        self.keys = [] if not keys else keys
        self.zones = [] if not zones else zones
        self.failover = failover
        self.subnets = [] if not subnets else subnets
        self.shared_networks = [] if not shared_networks else shared_networks
        self.groups = [] if not groups else groups
        self.hosts = [] if not hosts else hosts
        self.classes = [] if not classes else classes
        self.subclasses = [] if not subclasses else subclasses
        self.includes = [] if not includes else includes
        self.events = [] if not events else events
        self.custom_options = [] if not custom_options else custom_options
        self.option_expressions = [] if not option_expressions else \
            option_expressions
        super().__init__()

    def __str__(self) -&gt; str:
        return &#39;Global&#39;

    def __repr__(self) -&gt; str:
        return &#39;Global()&#39;

    def add_custom_option(self, option: CustomOption):
        self.custom_options.append(option)

    def find_custom_option(self, option):
        pass

    def delete_custom_option(self, option):
        pass

    def add_option_expression(self, option: OptionExpression):
        self.option_expressions.append(option)

    def find_option_expression(self, option):
        pass

    def delete_option_expression(self, option):
        pass

    def to_isc(self):
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        sort_order = {
            &#39;options&#39;: 1,
            &#39;includes&#39;: 2,
            &#39;custom_options&#39;: 3,
            &#39;option_expressions&#39;: 4,
            &#39;keys&#39;: 5,
            &#39;zones&#39;: 6,
            &#39;failover&#39;: 7,
            &#39;subnets&#39;: 8,
            &#39;shared_networks&#39;: 9,
            &#39;classes&#39;: 10,
            &#39;subclasses&#39;: 11,
            &#39;hosts&#39;: 12,
            &#39;groups&#39;: 13,
            &#39;events&#39;: 14
            }
        sorted_dict = sorted(
            self.__dict__.items(), key=lambda x: sort_order.get(x[0], 0))
        for key, value in sorted_dict:
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if value and key == &#39;failover&#39;:
                attrs.append(value.to_isc())
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{key};&#39;)
                else:
                    attrs.append(f&#39;not {key};&#39;)
            elif isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc())
            elif isinstance(value, bool):
                attrs.append(f&#39;{new_key} {str(value).lower()};&#39;)
            elif value in (&#39;deny&#39;, &#39;allow&#39;, &#39;ignore&#39;):
                attrs.append(f&#39;{value} {new_key};&#39;)
            elif value:
                attrs.append(f&#39;{new_key} {value};&#39;)
        attrs_str = &#34;\n&#34;.join(attrs)
        return (f&#39;{attrs_str}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
<li><a title="pyisc.dhcpd.mixin.Permissions" href="mixin.html#pyisc.dhcpd.mixin.Permissions">Permissions</a></li>
<li><a title="pyisc.dhcpd.mixin.OptionMixin" href="mixin.html#pyisc.dhcpd.mixin.OptionMixin">OptionMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.SubnetMixin" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin">SubnetMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.SharedNetworkMixin" href="mixin.html#pyisc.dhcpd.mixin.SharedNetworkMixin">SharedNetworkMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.GroupMixin" href="mixin.html#pyisc.dhcpd.mixin.GroupMixin">GroupMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.HostMixin" href="mixin.html#pyisc.dhcpd.mixin.HostMixin">HostMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.ClassMixin" href="mixin.html#pyisc.dhcpd.mixin.ClassMixin">ClassMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.SubClassMixin" href="mixin.html#pyisc.dhcpd.mixin.SubClassMixin">SubClassMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.KeyMixin" href="mixin.html#pyisc.dhcpd.mixin.KeyMixin">KeyMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.ZoneMixin" href="mixin.html#pyisc.dhcpd.mixin.ZoneMixin">ZoneMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.IncludeMixin" href="mixin.html#pyisc.dhcpd.mixin.IncludeMixin">IncludeMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.EventMixin" href="mixin.html#pyisc.dhcpd.mixin.EventMixin">EventMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Global.add_custom_option"><code class="name flex">
<span>def <span class="ident">add_custom_option</span></span>(<span>self, option:<a title="pyisc.dhcpd.nodes.CustomOption" href="#pyisc.dhcpd.nodes.CustomOption">CustomOption</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_custom_option(self, option: CustomOption):
    self.custom_options.append(option)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Global.add_option_expression"><code class="name flex">
<span>def <span class="ident">add_option_expression</span></span>(<span>self, option:<a title="pyisc.dhcpd.nodes.OptionExpression" href="#pyisc.dhcpd.nodes.OptionExpression">OptionExpression</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_option_expression(self, option: OptionExpression):
    self.option_expressions.append(option)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Global.delete_custom_option"><code class="name flex">
<span>def <span class="ident">delete_custom_option</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_custom_option(self, option):
    pass</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Global.delete_option_expression"><code class="name flex">
<span>def <span class="ident">delete_option_expression</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_option_expression(self, option):
    pass</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Global.find_custom_option"><code class="name flex">
<span>def <span class="ident">find_custom_option</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_custom_option(self, option):
    pass</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Global.find_option_expression"><code class="name flex">
<span>def <span class="ident">find_option_expression</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_option_expression(self, option):
    pass</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Global.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self):
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    sort_order = {
        &#39;options&#39;: 1,
        &#39;includes&#39;: 2,
        &#39;custom_options&#39;: 3,
        &#39;option_expressions&#39;: 4,
        &#39;keys&#39;: 5,
        &#39;zones&#39;: 6,
        &#39;failover&#39;: 7,
        &#39;subnets&#39;: 8,
        &#39;shared_networks&#39;: 9,
        &#39;classes&#39;: 10,
        &#39;subclasses&#39;: 11,
        &#39;hosts&#39;: 12,
        &#39;groups&#39;: 13,
        &#39;events&#39;: 14
        }
    sorted_dict = sorted(
        self.__dict__.items(), key=lambda x: sort_order.get(x[0], 0))
    for key, value in sorted_dict:
        new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        if value and key == &#39;failover&#39;:
            attrs.append(value.to_isc())
        elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
            if value:
                attrs.append(f&#39;{key};&#39;)
            else:
                attrs.append(f&#39;not {key};&#39;)
        elif isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc())
        elif isinstance(value, bool):
            attrs.append(f&#39;{new_key} {str(value).lower()};&#39;)
        elif value in (&#39;deny&#39;, &#39;allow&#39;, &#39;ignore&#39;):
            attrs.append(f&#39;{value} {new_key};&#39;)
        elif value:
            attrs.append(f&#39;{new_key} {value};&#39;)
    attrs_str = &#34;\n&#34;.join(attrs)
    return (f&#39;{attrs_str}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyisc.dhcpd.mixin.SubnetMixin" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin">SubnetMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.add_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.add_subnet">add_subnet</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.all_subnets" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.all_subnets">all_subnets</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.delete_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.delete_subnet">delete_subnet</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.find_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.find_subnet">find_subnet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyisc.dhcpd.nodes.Group"><code class="flex name class">
<span>class <span class="ident">Group</span></span>
<span>(</span><span>options:Union[List[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>],NoneType]=None, subnets:Union[List[<a title="pyisc.dhcpd.nodes.Subnet4" href="#pyisc.dhcpd.nodes.Subnet4">Subnet4</a>],NoneType]=None, shared_networks:Union[List[<a title="pyisc.dhcpd.nodes.SharedNetwork" href="#pyisc.dhcpd.nodes.SharedNetwork">SharedNetwork</a>],NoneType]=None, hosts:Union[List[<a title="pyisc.dhcpd.nodes.Host" href="#pyisc.dhcpd.nodes.Host">Host</a>],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an group declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>]</code></dt>
<dd>List of options.</dd>
<dt><strong><code>subnets</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Subnet4" href="#pyisc.dhcpd.nodes.Subnet4">Subnet4</a>]</code></dt>
<dd>List of subnets.</dd>
<dt><strong><code>shared_networks</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.SharedNetwork" href="#pyisc.dhcpd.nodes.SharedNetwork">SharedNetwork</a>]</code></dt>
<dd>List of
shared networks.</dd>
<dt><strong><code>hosts</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Host" href="#pyisc.dhcpd.nodes.Host">Host</a>]</code></dt>
<dd>List of hosts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Group(Parameters, SubnetMixin, SharedNetworkMixin, HostMixin,
            OptionMixin):
    &#34;&#34;&#34;Represents an group declaration.&#34;&#34;&#34;
    def __init__(
        self,
        options:            Union[List[Option], None] = None,
        subnets:            Union[List[Subnet4], None] = None,
        shared_networks:    Union[List[SharedNetwork], None] = None,
        hosts:              Union[List[Host], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            subnets (list[pyisc.dhcpd.nodes.Subnet4]): List of subnets.
            shared_networks (list[pyisc.dhcpd.nodes.SharedNetwork]): List of
                shared networks.
            hosts (list[pyisc.dhcpd.nodes.Host]): List of hosts.

        &#34;&#34;&#34;
        self.options = [] if not options else options
        self.subnets = [] if not subnets else subnets
        self.shared_networks = [] if not shared_networks else shared_networks
        # self.groups = [] if not groups else groups
        self.hosts = [] if not hosts else hosts

    def __str__(self) -&gt; str:
        return &#39;group&#39;

    def __repr__(self) -&gt; str:
        return &#39;Group()&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; group = Group()
            &gt;&gt;&gt; print(group.to_isc())
            group {
            }

            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; group.add_option(option)
            &gt;&gt;&gt; print(group.to_isc())
            group {
                option domain-name &#34;example.org&#34;;
            }

            &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
            &gt;&gt;&gt; group.add_subnet(subnet)
            &gt;&gt;&gt; print(group.to_isc())
            group {
                option domain-name &#34;example.org&#34;;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
            }

            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; pool.unknown_clients = &#39;deny&#39;
            &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;, end=&#39;10.10.10.250&#39;)
            &gt;&gt;&gt; pool.add_range(dhcp_range)
            &gt;&gt;&gt; subnet.add_pool(pool)
            &gt;&gt;&gt; print(group.to_isc())
            group {
                option domain-name &#34;example.org&#34;;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                    pool {
                        deny unknown-clients;
                        range 10.10.10.10 10.10.10.250;
                    }
                }
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif value:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
<li><a title="pyisc.dhcpd.mixin.SubnetMixin" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin">SubnetMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.SharedNetworkMixin" href="mixin.html#pyisc.dhcpd.mixin.SharedNetworkMixin">SharedNetworkMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.HostMixin" href="mixin.html#pyisc.dhcpd.mixin.HostMixin">HostMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.OptionMixin" href="mixin.html#pyisc.dhcpd.mixin.OptionMixin">OptionMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Group.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; group = Group()
&gt;&gt;&gt; print(group.to_isc())
group {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; option = Option(name='domain-name', value='&quot;example.org&quot;')
&gt;&gt;&gt; group.add_option(option)
&gt;&gt;&gt; print(group.to_isc())
group {
    option domain-name &quot;example.org&quot;;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; subnet = Subnet4('10.10.10.0/24')
&gt;&gt;&gt; group.add_subnet(subnet)
&gt;&gt;&gt; print(group.to_isc())
group {
    option domain-name &quot;example.org&quot;;
    subnet 10.10.10.0 netmask 255.255.255.0 {
    }
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool = Pool4()
&gt;&gt;&gt; pool.unknown_clients = 'deny'
&gt;&gt;&gt; dhcp_range = Range4(start='10.10.10.10', end='10.10.10.250')
&gt;&gt;&gt; pool.add_range(dhcp_range)
&gt;&gt;&gt; subnet.add_pool(pool)
&gt;&gt;&gt; print(group.to_isc())
group {
    option domain-name &quot;example.org&quot;;
    subnet 10.10.10.0 netmask 255.255.255.0 {
        pool {
            deny unknown-clients;
            range 10.10.10.10 10.10.10.250;
        }
    }
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; group = Group()
        &gt;&gt;&gt; print(group.to_isc())
        group {
        }

        &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
        &gt;&gt;&gt; group.add_option(option)
        &gt;&gt;&gt; print(group.to_isc())
        group {
            option domain-name &#34;example.org&#34;;
        }

        &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
        &gt;&gt;&gt; group.add_subnet(subnet)
        &gt;&gt;&gt; print(group.to_isc())
        group {
            option domain-name &#34;example.org&#34;;
            subnet 10.10.10.0 netmask 255.255.255.0 {
            }
        }

        &gt;&gt;&gt; pool = Pool4()
        &gt;&gt;&gt; pool.unknown_clients = &#39;deny&#39;
        &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;, end=&#39;10.10.10.250&#39;)
        &gt;&gt;&gt; pool.add_range(dhcp_range)
        &gt;&gt;&gt; subnet.add_pool(pool)
        &gt;&gt;&gt; print(group.to_isc())
        group {
            option domain-name &#34;example.org&#34;;
            subnet 10.10.10.0 netmask 255.255.255.0 {
                pool {
                    deny unknown-clients;
                    range 10.10.10.10 10.10.10.250;
                }
            }
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc(indent=child_indent))
        elif value:
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyisc.dhcpd.mixin.SubnetMixin" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin">SubnetMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.add_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.add_subnet">add_subnet</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.all_subnets" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.all_subnets">all_subnets</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.delete_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.delete_subnet">delete_subnet</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.find_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.find_subnet">find_subnet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyisc.dhcpd.nodes.Hardware"><code class="flex name class">
<span>class <span class="ident">Hardware</span></span>
<span>(</span><span>type:str, address:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an hardware parameter.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of the hardware instance.</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address of the hardware instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hardware:
    &#34;&#34;&#34;Represents an hardware parameter.&#34;&#34;&#34;
    def __init__(
        self,
        type:       str,
        address:    str
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            type (str): The type of the hardware instance.
            address (str): The address of the hardware instance.

        &#34;&#34;&#34;
        self.type = type
        self.address = address

    def __str__(self) -&gt; str:
        return f&#39;hardware {self.type} {self.address}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Hardware(type=&#34;{self.type}&#34;, address=&#34;{self.address}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; hardware = Hardware(type=&#39;ethernet&#39;, address=&#39;1234:5678:9abc&#39;)
            &gt;&gt;&gt; print(hardware.to_isc())
            hardware ethernet 1234:5678:9abc;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Hardware.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Hardware.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; hardware = Hardware(type='ethernet', address='1234:5678:9abc')
&gt;&gt;&gt; print(hardware.to_isc())
hardware ethernet 1234:5678:9abc;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; hardware = Hardware(type=&#39;ethernet&#39;, address=&#39;1234:5678:9abc&#39;)
        &gt;&gt;&gt; print(hardware.to_isc())
        hardware ethernet 1234:5678:9abc;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Host"><code class="flex name class">
<span>class <span class="ident">Host</span></span>
<span>(</span><span>name:str, always_broadcast:Union[bool,NoneType]=None, fixed_address:Union[str,NoneType]=None, fixed_address6:Union[str,NoneType]=None, fixed_prefix6:Union[str,NoneType]=None, hardware:Union[<a title="pyisc.dhcpd.nodes.Hardware" href="#pyisc.dhcpd.nodes.Hardware">Hardware</a>,NoneType]=None, host_identifier:Union[<a title="pyisc.dhcpd.nodes.HostIdentifier" href="#pyisc.dhcpd.nodes.HostIdentifier">HostIdentifier</a>,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an host declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the zone.</dd>
<dt><strong><code>always_broadcast</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Broadcast even if broadcast flag is
unset from clients.</dd>
<dt><strong><code>fixed_address</code></strong> :&ensp;<code>str, list[str]</code></dt>
<dd>One or more IPv4 address in
string format.</dd>
<dt><strong><code>fixed_address6</code></strong> :&ensp;<code>str</code></dt>
<dd>An IPv6 address in string format.</dd>
<dt><strong><code>fixed_prefix6</code></strong> :&ensp;<code>str, list[str]</code></dt>
<dd>One or more IPv prefixes.</dd>
<dt><strong><code>hardware</code></strong> :&ensp;<code><a title="pyisc.dhcpd.nodes.Hardware" href="#pyisc.dhcpd.nodes.Hardware">Hardware</a></code></dt>
<dd>The hardware address of
the client.</dd>
<dt><strong><code>host_identifier</code></strong> :&ensp;<code><a title="pyisc.dhcpd.nodes.HostIdentifier" href="#pyisc.dhcpd.nodes.HostIdentifier">HostIdentifier</a></code></dt>
<dd>IPv6
identifier for client</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Host(Parameters):
    &#34;&#34;&#34;Represents an host declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:               str,
        always_broadcast:   Union[bool, None] = None,
        fixed_address:      Union[str, None] = None,
        fixed_address6:     Union[str, None] = None,
        fixed_prefix6:      Union[str, None] = None,
        hardware:           Union[Hardware, None] = None,
        host_identifier:    Union[HostIdentifier, None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            always_broadcast (boolean): Broadcast even if broadcast flag is
                unset from clients.
            fixed_address (str, list[str]): One or more IPv4 address in
                string format.
            fixed_address6 (str): An IPv6 address in string format.
            fixed_prefix6 (str, list[str]): One or more IPv prefixes.
            hardware (pyisc.dhcpd.nodes.Hardware): The hardware address of
                the client.
            host_identifier (pyisc.dhcpd.nodes.HostIdentifier): IPv6
                identifier for client

        &#34;&#34;&#34;
        self.name = name
        self.always_broadcast = always_broadcast
        self.fixed_address = fixed_address
        self.fixed_address6 = fixed_address6
        self.fixed_prefix6 = fixed_prefix6
        self.hardware = hardware
        self.host_identifier = host_identifier
        super().__init__()

    def __str__(self) -&gt; str:
        return f&#39;host {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Host(name={self.name})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; host = Host(name=&#39;pluto.example.org&#39;)
            &gt;&gt;&gt; print(host.to_isc())
            host pluto.example.org {
            }

            &gt;&gt;&gt; host.always_broadcast = True
            &gt;&gt;&gt; print(host.to_isc())
            host pluto.example.org {
                always-broadcast true;
            }

            &gt;&gt;&gt; hardware = Hardware(type=&#39;ethernet&#39;, address=&#39;1234:5678:9abc&#39;)
            &gt;&gt;&gt; host.hardware = hardware
            &gt;&gt;&gt; print(host.to_isc())
            host pluto.example.org {
                always-broadcast true;
                hardware ethernet 1234:5678:9abc;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if hasattr(value, &#39;to_isc&#39;):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif isinstance(value, bool):
                attrs.append(
                    f&#39;{&#34; &#34; * child_indent}{new_key} {str(value).lower()};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Host.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Host.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; host = Host(name='pluto.example.org')
&gt;&gt;&gt; print(host.to_isc())
host pluto.example.org {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; host.always_broadcast = True
&gt;&gt;&gt; print(host.to_isc())
host pluto.example.org {
    always-broadcast true;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; hardware = Hardware(type='ethernet', address='1234:5678:9abc')
&gt;&gt;&gt; host.hardware = hardware
&gt;&gt;&gt; print(host.to_isc())
host pluto.example.org {
    always-broadcast true;
    hardware ethernet 1234:5678:9abc;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; host = Host(name=&#39;pluto.example.org&#39;)
        &gt;&gt;&gt; print(host.to_isc())
        host pluto.example.org {
        }

        &gt;&gt;&gt; host.always_broadcast = True
        &gt;&gt;&gt; print(host.to_isc())
        host pluto.example.org {
            always-broadcast true;
        }

        &gt;&gt;&gt; hardware = Hardware(type=&#39;ethernet&#39;, address=&#39;1234:5678:9abc&#39;)
        &gt;&gt;&gt; host.hardware = hardware
        &gt;&gt;&gt; print(host.to_isc())
        host pluto.example.org {
            always-broadcast true;
            hardware ethernet 1234:5678:9abc;
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        if hasattr(value, &#39;to_isc&#39;):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
        elif isinstance(value, bool):
            attrs.append(
                f&#39;{&#34; &#34; * child_indent}{new_key} {str(value).lower()};&#39;)
        elif all((value, key != &#39;name&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.HostIdentifier"><code class="flex name class">
<span>class <span class="ident">HostIdentifier</span></span>
<span>(</span><span>option_name:str, option_data:str, number:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an host identifier parameter.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>option_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the option.</dd>
<dt><strong><code>option_data</code></strong> :&ensp;<code>str</code></dt>
<dd>The value of the option.</dd>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>Relay number. If used this will automatically change
the outputted isc configuration string to a v6relopt.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HostIdentifier:
    &#34;&#34;&#34;Represents an host identifier parameter.&#34;&#34;&#34;
    def __init__(
        self,
        option_name:    str,
        option_data:    str,
        number:         Union[int, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            option_name (str): The name of the option.
            option_data (str): The value of the option.
            number (int): Relay number. If used this will automatically change
                the outputted isc configuration string to a v6relopt.

        &#34;&#34;&#34;
        self.option_name = option_name
        self.option_data = option_data
        self.number = number

    def __str__(self) -&gt; str:
        if self.number:
            base_string = f&#39;host-identifier v6relopt {self.number}&#39;
        else:
            base_string = &#39;host-identifier option&#39;
        return f&#39;{base_string} {self.option_name} {self.option_data}&#39;

    def __repr__(self) -&gt; str:
        if self.number:
            return (f&#39;HostIdentifier(&#39;
                    f&#39;number={self.number}, option_name={self.option_name},&#39;
                    f&#39;option_data={self.option_data})&#39;)
        else:
            return (f&#39;HostIdentifier(option_name={self.option_name}, &#39;
                    f&#39;option_data={self.option_data})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        The output is dependant upon what attributes are set. If number is set
        it is assumed that the host identifier is of the v6relopt type and the
        produced configuration will reflect that.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; host_id = HostIdentifier(option_name=&#39;domain-name&#39;,
                                         option_data=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; print(host_id.to_isc())
            host-identifier option domain-name &#34;example.org&#34;;

            &gt;&gt;&gt; host_id = HostIdentifier(option_name=&#39;domain-name&#39;,
                                         option_data=&#39;&#34;example.org&#34;&#39;, number=1)
            &gt;&gt;&gt; print(host_id.to_isc())
            host-identifier v6relopt 1 domain-name &#34;example.org&#34;;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.HostIdentifier.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.HostIdentifier.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<p>The output is dependant upon what attributes are set. If number is set
it is assumed that the host identifier is of the v6relopt type and the
produced configuration will reflect that.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; host_id = HostIdentifier(option_name='domain-name',
                             option_data='&quot;example.org&quot;')
&gt;&gt;&gt; print(host_id.to_isc())
host-identifier option domain-name &quot;example.org&quot;;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; host_id = HostIdentifier(option_name='domain-name',
                             option_data='&quot;example.org&quot;', number=1)
&gt;&gt;&gt; print(host_id.to_isc())
host-identifier v6relopt 1 domain-name &quot;example.org&quot;;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    The output is dependant upon what attributes are set. If number is set
    it is assumed that the host identifier is of the v6relopt type and the
    produced configuration will reflect that.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; host_id = HostIdentifier(option_name=&#39;domain-name&#39;,
                                     option_data=&#39;&#34;example.org&#34;&#39;)
        &gt;&gt;&gt; print(host_id.to_isc())
        host-identifier option domain-name &#34;example.org&#34;;

        &gt;&gt;&gt; host_id = HostIdentifier(option_name=&#39;domain-name&#39;,
                                     option_data=&#39;&#34;example.org&#34;&#39;, number=1)
        &gt;&gt;&gt; print(host_id.to_isc())
        host-identifier v6relopt 1 domain-name &#34;example.org&#34;;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Include"><code class="flex name class">
<span>class <span class="ident">Include</span></span>
<span>(</span><span>filename:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the include declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>A path to the file that is to be included.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Include:
    &#34;&#34;&#34;Represents the include declaration.&#34;&#34;&#34;
    def __init__(self, filename: str) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            filename (str): A path to the file that is to be included.

        &#34;&#34;&#34;
        self.filename = filename

    def __str__(self) -&gt; str:
        return f&#39;include {self.filename}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Include(filename={self.filename})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; include = Include(filename=&#39;/etc/dhcpd-keys.conf&#39;)
            &gt;&gt;&gt; print(include.to_isc())
            include /etc/dhcpd-keys.conf;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Include.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Include.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; include = Include(filename='/etc/dhcpd-keys.conf')
&gt;&gt;&gt; print(include.to_isc())
include /etc/dhcpd-keys.conf;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; include = Include(filename=&#39;/etc/dhcpd-keys.conf&#39;)
        &gt;&gt;&gt; print(include.to_isc())
        include /etc/dhcpd-keys.conf;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Key"><code class="flex name class">
<span>class <span class="ident">Key</span></span>
<span>(</span><span>name:str, algorithm:Union[str,NoneType]=None, secret:Union[str,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an key declaration and parameter.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the key instance.</dd>
<dt><strong><code>algorithm</code></strong> :&ensp;<code>str</code></dt>
<dd>The algorithm used for the key.</dd>
<dt><strong><code>secret</code></strong> :&ensp;<code>str</code></dt>
<dd>The secret used by the key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Key:
    &#34;&#34;&#34;Represents an key declaration and parameter.&#34;&#34;&#34;
    def __init__(
        self,
        name:       str,
        algorithm:  Union[str, None] = None,
        secret:     Union[str, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the key instance.
            algorithm (str): The algorithm used for the key.
            secret (str): The secret used by the key.

        &#34;&#34;&#34;
        self.name = name
        self.algorithm = algorithm
        self.secret = secret

    def __str__(self) -&gt; str:
        return f&#39;key {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Key(name=&#34;{self.name}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        &gt;&gt;&gt; key = Key(name=&#39;DHCP_UPDATER&#39;)
        &gt;&gt;&gt; print(key.to_isc())
        key DHCP_UPDATER {
        }

        &gt;&gt;&gt; key.secret = &#39;Ofakekeyfakekeyfakekey==&#39;
        &gt;&gt;&gt; print(key.to_isc())
        key DHCP_UPDATER {
            secret Ofakekeyfakekeyfakekey==;
        }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Key.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Key.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<pre><code class="python-repl">&gt;&gt;&gt; key = Key(name='DHCP_UPDATER')
&gt;&gt;&gt; print(key.to_isc())
key DHCP_UPDATER {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; key.secret = 'Ofakekeyfakekeyfakekey=='
&gt;&gt;&gt; print(key.to_isc())
key DHCP_UPDATER {
    secret Ofakekeyfakekeyfakekey==;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    &gt;&gt;&gt; key = Key(name=&#39;DHCP_UPDATER&#39;)
    &gt;&gt;&gt; print(key.to_isc())
    key DHCP_UPDATER {
    }

    &gt;&gt;&gt; key.secret = &#39;Ofakekeyfakekeyfakekey==&#39;
    &gt;&gt;&gt; print(key.to_isc())
    key DHCP_UPDATER {
        secret Ofakekeyfakekeyfakekey==;
    }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if all((value, key != &#39;name&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Option"><code class="flex name class">
<span>class <span class="ident">Option</span></span>
<span>(</span><span>value:str, name:Union[str,NoneType]=None, number:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an dhcp option.</p>
<p>Initialize attributes for the class.</p>
<p>Name or number (or both) must be given. If value contains a comma it
is assumed that the value will be a list and the submitted string will
be saved accordingly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the dhcp option.</dd>
<dt><strong><code>number</code></strong> :&ensp;<code>str</code></dt>
<dd>The number of the dhcp option.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The value of the option.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Option:
    &#34;&#34;&#34;Represents an dhcp option.&#34;&#34;&#34;
    def __init__(
        self,
        value:  str,
        name:   Union[str, None] = None,
        number: Union[int, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Name or number (or both) must be given. If value contains a comma it
        is assumed that the value will be a list and the submitted string will
        be saved accordingly.

        Args:
            name (str): The name of the dhcp option.
            number (str): The number of the dhcp option.
            value (str): The value of the option.

        &#34;&#34;&#34;
        if not name and not number:
            raise TypeError(&#39;__init__() missing attribute: name or number&#39;)
        self.name = name
        self.number = number
        self.value = value

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, value: str):
        if &#39;,&#39; in str(value):
            self.__value = [x.strip() for x in value.split(&#39;,&#39;)]
        else:
            self.__value = value

    def __str__(self) -&gt; str:
        if isinstance(self.value, list):
            return (f&#39;option {self.name.replace(&#34;_&#34;,&#34;-&#34;) if self.name else self.number} &#39;
                    f&#39;{&#34;, &#34;.join(self.value)}&#39;)
        elif isinstance(self.value, bool):
            return (f&#39;option {self.name.replace(&#34;_&#34;,&#34;-&#34;) if self.name else self.number}&#39;)
        else:
            return (f&#39;option {self.name.replace(&#34;_&#34;,&#34;-&#34;) if self.name else self.number} &#39;
                    f&#39;{self.value}&#39;)

    def __repr__(self) -&gt; str:
        key = f&#39;name=&#34;{self.name}&#34;&#39; if self.name else f&#39;number=&#34;{self.number}&#34;&#39;
        if isinstance(self.value, list):
            value = f&#39;value={self.value}&#39;
        else:
            value = f&#39;value=&#34;{self.value}&#34;&#39;
        return f&#39;Option({key}, {value})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; print(option.to_isc())
            option domain-name &#34;example.org&#34;;

            &gt;&gt;&gt; option = Option(number=105, value=&#39;&#34;test&#34;&#39;)
            &gt;&gt;&gt; print(option.to_isc())
            option 105 &#34;test&#34;;

            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, number=98,
                                value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; print(option.to_isc())
            option domain-name &#34;example.org&#34;;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Option.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    return self.__value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Option.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Option.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; option = Option(name='domain-name', value='&quot;example.org&quot;')
&gt;&gt;&gt; print(option.to_isc())
option domain-name &quot;example.org&quot;;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; option = Option(number=105, value='&quot;test&quot;')
&gt;&gt;&gt; print(option.to_isc())
option 105 &quot;test&quot;;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; option = Option(name='domain-name', number=98,
                    value='&quot;example.org&quot;')
&gt;&gt;&gt; print(option.to_isc())
option domain-name &quot;example.org&quot;;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
        &gt;&gt;&gt; print(option.to_isc())
        option domain-name &#34;example.org&#34;;

        &gt;&gt;&gt; option = Option(number=105, value=&#39;&#34;test&#34;&#39;)
        &gt;&gt;&gt; print(option.to_isc())
        option 105 &#34;test&#34;;

        &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, number=98,
                            value=&#39;&#34;example.org&#34;&#39;)
        &gt;&gt;&gt; print(option.to_isc())
        option domain-name &#34;example.org&#34;;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.OptionExpression"><code class="flex name class">
<span>class <span class="ident">OptionExpression</span></span>
<span>(</span><span>name:str, value:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents option with an expression as its value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptionExpression:
    &#34;&#34;&#34;Represents option with an expression as its value.&#34;&#34;&#34;
    def __init__(
        self,
        name:   str,
        value:  str
    ) -&gt; None:
        self.name = name
        self.value = value

    def __str__(self) -&gt; str:
        return f&#39;option {self.name} = {self.value}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;OptionExpression(name={self.name}, value={self.value})&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.OptionExpression.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool4"><code class="flex name class">
<span>class <span class="ident">Pool4</span></span>
<span>(</span><span>known_clients:Union[str,NoneType]=None, unknown_clients:Union[str,NoneType]=None, allow_members_of:Union[List[str],NoneType]=None, deny_members_of:Union[List[str],NoneType]=None, dynamic_bootp_clients:Union[str,NoneType]=None, authenticated_clients:Union[str,NoneType]=None, unauthenticated_clients:Union[str,NoneType]=None, all_clients:Union[str,NoneType]=None, allow_after:Union[int,NoneType]=None, deny_after:Union[int,NoneType]=None, failover:Union[<a title="pyisc.dhcpd.nodes.Failover" href="#pyisc.dhcpd.nodes.Failover">Failover</a>,NoneType]=None, ranges:Union[List[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an pool declaration for IPv4 objects.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>known_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies known clients.</dd>
<dt><strong><code>unknown_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies unknown clients.</dd>
<dt><strong><code>allow_members_of</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>List of allowed classes.</dd>
<dt><strong><code>deny_members_of</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>List of denied classes.</dd>
<dt><strong><code>dynamic_bootp_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies bootp clients.</dd>
<dt><strong><code>authenticated_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies authenticated
clients.</dd>
<dt><strong><code>unauthenticated_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies unauthenticated
clients.</dd>
<dt><strong><code>all_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies all clients.</dd>
<dt><strong><code>allow_after</code></strong> :&ensp;<code>int</code></dt>
<dd>Allows clients after a given date.</dd>
<dt><strong><code>deny_after</code></strong> :&ensp;<code>int</code></dt>
<dd>Denies clients after a given date.</dd>
<dt><strong><code>failover</code></strong> :&ensp;<code><a title="pyisc.dhcpd.nodes.Failover" href="#pyisc.dhcpd.nodes.Failover">Failover</a></code></dt>
<dd>The failover peer of the
pool.</dd>
<dt><strong><code>ranges</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>]</code></dt>
<dd>List of IPv4 ranges
belonging to the pool.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pool4(RangeMixin):
    &#34;&#34;&#34;Represents an pool declaration for IPv4 objects.&#34;&#34;&#34;
    def __init__(
        self,
        known_clients:               Union[str, None] = None,
        unknown_clients:             Union[str, None] = None,
        allow_members_of:            Union[List[str], None] = None,
        deny_members_of:             Union[List[str], None] = None,
        dynamic_bootp_clients:       Union[str, None] = None,
        authenticated_clients:       Union[str, None] = None,
        unauthenticated_clients:     Union[str, None] = None,
        all_clients:                 Union[str, None] = None,
        allow_after:                 Union[int, None] = None,
        deny_after:                  Union[int, None] = None,
        failover:                    Union[Failover, None] = None,
        ranges:                      Union[List[Range4], None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            known_clients (str): Allows or denies known clients.
            unknown_clients (str): Allows or denies unknown clients.
            allow_members_of (list[str]): List of allowed classes.
            deny_members_of (list[str]): List of denied classes.
            dynamic_bootp_clients (str): Allows or denies bootp clients.
            authenticated_clients (str): Allows or denies authenticated
                clients.
            unauthenticated_clients (str): Allows or denies unauthenticated
                clients.
            all_clients (str): Allows or denies all clients.
            allow_after (int): Allows clients after a given date.
            deny_after (int): Denies clients after a given date.
            failover (pyisc.dhcpd.nodes.Failover): The failover peer of the
                pool.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of IPv4 ranges
                belonging to the pool.

        &#34;&#34;&#34;
        self.known_clients = known_clients
        self.unknown_clients = unknown_clients
        self.allow_members_of = [] if not allow_members_of else allow_members_of
        self.deny_members_of = [] if not deny_members_of else deny_members_of
        self.dynamic_bootp_clients = dynamic_bootp_clients
        self.authenticated_clients = authenticated_clients
        self.unauthenticated_clients = unauthenticated_clients
        self.all_clients = all_clients
        self.allow_after = allow_after
        self.deny_after = deny_after
        self.failover = failover
        self.ranges = [] if not ranges else ranges

    def __str__(self) -&gt; str:
        return &#39;pool&#39;

    def __repr__(self) -&gt; str:
        return &#39;Pool4()&#39;

    def add_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.append(member)

    def delete_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.remove(member)

    def add_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.append(member)

    def delete_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.remove(member)

    def object_tree(self, indent=0):
        attrs = []
        child_indent = indent+4
        for dhcp_range in self.ranges:
            attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.object_tree()}&#39;)
        return_str = f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        return f&#39;{return_str}{attrs_str}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
            }

            &gt;&gt;&gt; pool.known_clients = &#39;allow&#39;
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
            }

            &gt;&gt;&gt; pool.unknown_clients = &#39;deny&#39;
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
            }

            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
                allow members of &#34;foo&#34;;
            }

            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;bar&#34;&#39;)
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
                allow members of &#34;foo&#34;;
                allow members of &#34;bar&#34;;
            }

            &gt;&gt;&gt; pool.delete_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                deny unknown-clients;
                allow members of &#34;bar&#34;;
            }

            &gt;&gt;&gt; failover = Failover(name=&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; pool.failover = failover
            &gt;&gt;&gt; print(pool.to_isc())
            pool {
                allow known-clients;
                allow members of &#34;foo&#34;;
                failover peer &#34;foo&#34;;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if &#39;known&#39; in key:
                new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            else:
                new_key = key.replace(&#34;_&#34;, &#34; &#34;)
            if all((value, &#39;members_of&#39; in key)):
                for subvalue in value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {subvalue};&#39;)
            elif all((value, key == &#39;ranges&#39;)):
                for dhcp_range in self.ranges:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.to_isc()}&#39;)
            elif all((value, key == &#39;failover&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
            elif any((value == &#39;allow&#39;, value == &#39;deny&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value} {new_key};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.RangeMixin" href="mixin.html#pyisc.dhcpd.mixin.RangeMixin">RangeMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Pool4.add_allowed_member"><code class="name flex">
<span>def <span class="ident">add_allowed_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_allowed_member(self, member: str) -&gt; None:
    self.allow_members_of.append(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool4.add_denied_member"><code class="name flex">
<span>def <span class="ident">add_denied_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_denied_member(self, member: str) -&gt; None:
    self.deny_members_of.append(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool4.delete_allowed_member"><code class="name flex">
<span>def <span class="ident">delete_allowed_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_allowed_member(self, member: str) -&gt; None:
    self.allow_members_of.remove(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool4.delete_denied_member"><code class="name flex">
<span>def <span class="ident">delete_denied_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_denied_member(self, member: str) -&gt; None:
    self.deny_members_of.remove(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool4.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    attrs = []
    child_indent = indent+4
    for dhcp_range in self.ranges:
        attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.object_tree()}&#39;)
    return_str = f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    return f&#39;{return_str}{attrs_str}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool4.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; pool = Pool4()
&gt;&gt;&gt; print(pool.to_isc())
pool {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool.known_clients = 'allow'
&gt;&gt;&gt; print(pool.to_isc())
pool {
    allow known-clients;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool.unknown_clients = 'deny'
&gt;&gt;&gt; print(pool.to_isc())
pool {
    allow known-clients;
    deny unknown-clients;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool.add_allowed_member('&quot;foo&quot;')
&gt;&gt;&gt; print(pool.to_isc())
pool {
    allow known-clients;
    deny unknown-clients;
    allow members of &quot;foo&quot;;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool.add_allowed_member('&quot;bar&quot;')
&gt;&gt;&gt; print(pool.to_isc())
pool {
    allow known-clients;
    deny unknown-clients;
    allow members of &quot;foo&quot;;
    allow members of &quot;bar&quot;;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool.delete_allowed_member('&quot;foo&quot;')
&gt;&gt;&gt; print(pool.to_isc())
pool {
    allow known-clients;
    deny unknown-clients;
    allow members of &quot;bar&quot;;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; failover = Failover(name='&quot;foo&quot;')
&gt;&gt;&gt; pool.failover = failover
&gt;&gt;&gt; print(pool.to_isc())
pool {
    allow known-clients;
    allow members of &quot;foo&quot;;
    failover peer &quot;foo&quot;;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; pool = Pool4()
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
        }

        &gt;&gt;&gt; pool.known_clients = &#39;allow&#39;
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
            allow known-clients;
        }

        &gt;&gt;&gt; pool.unknown_clients = &#39;deny&#39;
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
            allow known-clients;
            deny unknown-clients;
        }

        &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
            allow known-clients;
            deny unknown-clients;
            allow members of &#34;foo&#34;;
        }

        &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;bar&#34;&#39;)
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
            allow known-clients;
            deny unknown-clients;
            allow members of &#34;foo&#34;;
            allow members of &#34;bar&#34;;
        }

        &gt;&gt;&gt; pool.delete_allowed_member(&#39;&#34;foo&#34;&#39;)
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
            allow known-clients;
            deny unknown-clients;
            allow members of &#34;bar&#34;;
        }

        &gt;&gt;&gt; failover = Failover(name=&#39;&#34;foo&#34;&#39;)
        &gt;&gt;&gt; pool.failover = failover
        &gt;&gt;&gt; print(pool.to_isc())
        pool {
            allow known-clients;
            allow members of &#34;foo&#34;;
            failover peer &#34;foo&#34;;
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if &#39;known&#39; in key:
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        else:
            new_key = key.replace(&#34;_&#34;, &#34; &#34;)
        if all((value, &#39;members_of&#39; in key)):
            for subvalue in value:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {subvalue};&#39;)
        elif all((value, key == &#39;ranges&#39;)):
            for dhcp_range in self.ranges:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.to_isc()}&#39;)
        elif all((value, key == &#39;failover&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
        elif any((value == &#39;allow&#39;, value == &#39;deny&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value} {new_key};&#39;)
        elif all((value, key != &#39;name&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool6"><code class="flex name class">
<span>class <span class="ident">Pool6</span></span>
<span>(</span><span>known_clients:Union[str,NoneType]=None, unknown_clients:Union[str,NoneType]=None, allow_members_of:Union[List[str],NoneType]=None, deny_members_of:Union[List[str],NoneType]=None, dynamic_bootp_clients:Union[str,NoneType]=None, authenticated_clients:Union[str,NoneType]=None, unauthenticated_clients:Union[str,NoneType]=None, all_clients:Union[str,NoneType]=None, allow_after:Union[int,NoneType]=None, deny_after:Union[int,NoneType]=None, failover:Union[<a title="pyisc.dhcpd.nodes.Failover" href="#pyisc.dhcpd.nodes.Failover">Failover</a>,NoneType]=None, ranges:Union[List[<a title="pyisc.dhcpd.nodes.Range6" href="#pyisc.dhcpd.nodes.Range6">Range6</a>],NoneType]=None, prefix6:Union[<a title="pyisc.dhcpd.nodes.Prefix6" href="#pyisc.dhcpd.nodes.Prefix6">Prefix6</a>,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an pool declaration for IPv6 objects.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>known_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies known clients.</dd>
<dt><strong><code>unknown_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies unknown clients.</dd>
<dt><strong><code>allow_members_of</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>List of allowed classes.</dd>
<dt><strong><code>deny_members_of</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>List of denied classes.</dd>
<dt><strong><code>dynamic_bootp_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies bootp clients.</dd>
<dt><strong><code>authenticated_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies authenticated
clients.</dd>
<dt><strong><code>unauthenticated_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies unauthenticated
clients.</dd>
<dt><strong><code>all_clients</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows or denies all clients.</dd>
<dt><strong><code>allow_after</code></strong> :&ensp;<code>int</code></dt>
<dd>Allows clients after a given date.</dd>
<dt><strong><code>deny_after</code></strong> :&ensp;<code>int</code></dt>
<dd>Denies clients after a given date.</dd>
<dt><strong><code>failover</code></strong> :&ensp;<code><a title="pyisc.dhcpd.nodes.Failover" href="#pyisc.dhcpd.nodes.Failover">Failover</a></code></dt>
<dd>The failover peer of the
pool.</dd>
<dt><strong><code>ranges</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>]</code></dt>
<dd>List of IPv4 ranges
belonging to the pool.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pool6:
    &#34;&#34;&#34;Represents an pool declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        known_clients:              Union[str, None] = None,
        unknown_clients:            Union[str, None] = None,
        allow_members_of:           Union[List[str], None] = None,
        deny_members_of:            Union[List[str], None] = None,
        dynamic_bootp_clients:      Union[str, None] = None,
        authenticated_clients:      Union[str, None] = None,
        unauthenticated_clients:    Union[str, None] = None,
        all_clients:                Union[str, None] = None,
        allow_after:                Union[int, None] = None,
        deny_after:                 Union[int, None] = None,
        failover:                   Union[Failover, None] = None,
        ranges:                     Union[List[Range6], None] = None,
        prefix6:                    Union[Prefix6, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            known_clients (str): Allows or denies known clients.
            unknown_clients (str): Allows or denies unknown clients.
            allow_members_of (list[str]): List of allowed classes.
            deny_members_of (list[str]): List of denied classes.
            dynamic_bootp_clients (str): Allows or denies bootp clients.
            authenticated_clients (str): Allows or denies authenticated
                clients.
            unauthenticated_clients (str): Allows or denies unauthenticated
                clients.
            all_clients (str): Allows or denies all clients.
            allow_after (int): Allows clients after a given date.
            deny_after (int): Denies clients after a given date.
            failover (pyisc.dhcpd.nodes.Failover): The failover peer of the
                pool.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of IPv4 ranges
                belonging to the pool.

        &#34;&#34;&#34;
        self.known_clients = known_clients
        self.unknown_clients = unknown_clients
        self.allow_members_of = [] if not allow_members_of else allow_members_of
        self.deny_members_of = [] if not deny_members_of else deny_members_of
        self.dynamic_bootp_clients = dynamic_bootp_clients
        self.authenticated_clients = authenticated_clients
        self.unauthenticated_clients = unauthenticated_clients
        self.all_clients = all_clients
        self.allow_after = allow_after
        self.deny_after = deny_after
        self.failover = failover
        self.ranges = [] if not ranges else ranges
        self.prefix6 = prefix6

    def __str__(self) -&gt; str:
        return &#39;pool&#39;

    def __repr__(self) -&gt; str:
        return &#39;Pool4()&#39;

    def add_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.append(member)

    def delete_allowed_member(self, member: str) -&gt; None:
        self.allow_members_of.remove(member)

    def add_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.append(member)

    def delete_denied_member(self, member: str) -&gt; None:
        self.deny_members_of.remove(member)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if &#39;known&#39; in key:
                new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            else:
                new_key = key.replace(&#34;_&#34;, &#34; &#34;)
            if all((value, &#39;members_of&#39; in key)):
                for subvalue in value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {subvalue};&#39;)
            elif all((value, key == &#39;ranges&#39;)):
                for dhcp_range in self.ranges:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.to_isc()}&#39;)
            # elif all((value, key == &#39;prefix6&#39;)):
            #     attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif hasattr(value, &#39;to_isc&#39;):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif all((value, key == &#39;failover&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
            elif any((value == &#39;allow&#39;, value == &#39;deny&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value} {new_key};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Pool6.add_allowed_member"><code class="name flex">
<span>def <span class="ident">add_allowed_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_allowed_member(self, member: str) -&gt; None:
    self.allow_members_of.append(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool6.add_denied_member"><code class="name flex">
<span>def <span class="ident">add_denied_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_denied_member(self, member: str) -&gt; None:
    self.deny_members_of.append(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool6.delete_allowed_member"><code class="name flex">
<span>def <span class="ident">delete_allowed_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_allowed_member(self, member: str) -&gt; None:
    self.allow_members_of.remove(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool6.delete_denied_member"><code class="name flex">
<span>def <span class="ident">delete_denied_member</span></span>(<span>self, member:str) >NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_denied_member(self, member: str) -&gt; None:
    self.deny_members_of.remove(member)</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool6.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Pool6.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if &#39;known&#39; in key:
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        else:
            new_key = key.replace(&#34;_&#34;, &#34; &#34;)
        if all((value, &#39;members_of&#39; in key)):
            for subvalue in value:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {subvalue};&#39;)
        elif all((value, key == &#39;ranges&#39;)):
            for dhcp_range in self.ranges:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{dhcp_range.to_isc()}&#39;)
        # elif all((value, key == &#39;prefix6&#39;)):
        #     attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
        elif hasattr(value, &#39;to_isc&#39;):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
        elif all((value, key == &#39;failover&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
        elif any((value == &#39;allow&#39;, value == &#39;deny&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value} {new_key};&#39;)
        elif all((value, key != &#39;name&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Prefix6"><code class="flex name class">
<span>class <span class="ident">Prefix6</span></span>
<span>(</span><span>start:str, end:str, bits:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an prefix declaration for IPv6 objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Prefix6:
    &#34;&#34;&#34;Represents an prefix declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        start:  str,
        end:    str,
        bits:   str
    ) -&gt; None:
        self.start = start
        self.end = end
        self.bits = bits

    def __str__(self) -&gt; str:
        return f&#39;prefix6 {self.start} {self.end} {self.bits}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Prefix6(start={self.start}, end={self.end}, bits={self.bits})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; prefix = Prefix6(start=&#39;2001:db8:0:100::&#39;, end=&#39;2001:db8:0:f00::&#39;, bits=&#39;/56&#39;)
            &gt;&gt;&gt; print(prefix.to_isc())
            prefix6 2001:db8:0:100:: 2001:db8:0:f00:: /56;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Prefix6.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Prefix6.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; prefix = Prefix6(start='2001:db8:0:100::', end='2001:db8:0:f00::', bits='/56')
&gt;&gt;&gt; print(prefix.to_isc())
prefix6 2001:db8:0:100:: 2001:db8:0:f00:: /56;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; prefix = Prefix6(start=&#39;2001:db8:0:100::&#39;, end=&#39;2001:db8:0:f00::&#39;, bits=&#39;/56&#39;)
        &gt;&gt;&gt; print(prefix.to_isc())
        prefix6 2001:db8:0:100:: 2001:db8:0:f00:: /56;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Range4"><code class="flex name class">
<span>class <span class="ident">Range4</span></span>
<span>(</span><span>start:str, end:Union[str,NoneType]=None, dynamic_bootp:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the range declaration for IPv4 objects.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>str</code></dt>
<dd>The first or lowest IP address in the range.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>str</code></dt>
<dd>The last or highest IP address in the range.</dd>
<dt><strong><code>dynamic_bootp</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If set allows BOOTP clients to get
dynamically assigned addresses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Range4:
    &#34;&#34;&#34;Represents the range declaration for IPv4 objects.&#34;&#34;&#34;
    def __init__(
        self,
        start:          str,
        end:            Union[str, None] = None,
        dynamic_bootp:  bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            start (str): The first or lowest IP address in the range.
            end (str): The last or highest IP address in the range.
            dynamic_bootp (boolean): If set allows BOOTP clients to get
                dynamically assigned addresses.

        &#34;&#34;&#34;
        self.start = start
        self.end = end
        self.dynamic_bootp = dynamic_bootp

    def __str__(self) -&gt; str:
        list_comp = [data for data in (self.start, self.end) if data]
        if self.dynamic_bootp:
            return f&#39;range dynamic-bootp {&#34; &#34;.join(list_comp)}&#39;
        else:
            return f&#39;range {&#34; &#34;.join(list_comp)}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;Range4(start={self.start}, end={self.end}, &#39;
                f&#39;dynamic_bootp={self.dynamic_bootp})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;)
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range 10.10.10.10;

            &gt;&gt;&gt; dhcp_range.end = &#39;10.10.10.250&#39;
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range 10.10.10.10 10.10.10.250;

            &gt;&gt;&gt; dhcp_range.dynamic_bootp = True
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range dynamic-bootp 10.10.10.10 10.10.10.250;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Range4.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Range4.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range = Range4(start='10.10.10.10')
&gt;&gt;&gt; print(dhcp_range.to_isc())
range 10.10.10.10;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range.end = '10.10.10.250'
&gt;&gt;&gt; print(dhcp_range.to_isc())
range 10.10.10.10 10.10.10.250;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range.dynamic_bootp = True
&gt;&gt;&gt; print(dhcp_range.to_isc())
range dynamic-bootp 10.10.10.10 10.10.10.250;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;)
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range 10.10.10.10;

        &gt;&gt;&gt; dhcp_range.end = &#39;10.10.10.250&#39;
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range 10.10.10.10 10.10.10.250;

        &gt;&gt;&gt; dhcp_range.dynamic_bootp = True
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range dynamic-bootp 10.10.10.10 10.10.10.250;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Range6"><code class="flex name class">
<span>class <span class="ident">Range6</span></span>
<span>(</span><span>start:str, end:Union[str,NoneType]=None, temporary:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the range declaration for IPv6 objects.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>str</code></dt>
<dd>The first or lowest IP address in the range or the
subnet. This could also be set as a prefix in cidr notation.
And if so the end attribute should be omitted.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>str</code></dt>
<dd>The last or highest IP address in the range.</dd>
<dt><strong><code>temporary</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If set makes the prefix available for
temporary (RFC 4941) addresses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Range6:
    &#34;&#34;&#34;Represents the range declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        start:      str,
        end:        Union[str, None] = None,
        temporary:  bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            start (str): The first or lowest IP address in the range or the
                subnet. This could also be set as a prefix in cidr notation. 
                And if so the end attribute should be omitted.
            end (str): The last or highest IP address in the range.
            temporary (boolean): If set makes the prefix available for
                temporary (RFC 4941) addresses.

        &#34;&#34;&#34;
        self.start = start
        self.end = end
        self.temporary = temporary

    def __str__(self) -&gt; str:
        list_comp = [data for data in (self.start, self.end) if data]
        if self.temporary:
            return f&#39;range6 {&#34; &#34;.join(list_comp)} temporary&#39;
        else:
            return f&#39;range6 {&#34; &#34;.join(list_comp)}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;Range6(start={self.start}, end={self.end}, &#39;
                f&#39;temporary={self.temporary})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; dhcp_range = Range6(start=&#39;dead:beef::1&#39;)
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef::1;

            &gt;&gt;&gt; dhcp_range.end = &#39;dead:beef::128&#39;
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef::1 dead:beef::128;

            &gt;&gt;&gt; dhcp_range.temporary = True
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef::1 dead:beef::128 temporary;

            &gt;&gt;&gt; dhcp_range = Range6(start=&#39;dead:beef:0:f1::/64&#39;)
            &gt;&gt;&gt; print(dhcp_range.to_isc())
            range6 dead:beef:0:f1::/64;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Range6.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Range6.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range = Range6(start='dead:beef::1')
&gt;&gt;&gt; print(dhcp_range.to_isc())
range6 dead:beef::1;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range.end = 'dead:beef::128'
&gt;&gt;&gt; print(dhcp_range.to_isc())
range6 dead:beef::1 dead:beef::128;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range.temporary = True
&gt;&gt;&gt; print(dhcp_range.to_isc())
range6 dead:beef::1 dead:beef::128 temporary;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; dhcp_range = Range6(start='dead:beef:0:f1::/64')
&gt;&gt;&gt; print(dhcp_range.to_isc())
range6 dead:beef:0:f1::/64;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; dhcp_range = Range6(start=&#39;dead:beef::1&#39;)
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range6 dead:beef::1;

        &gt;&gt;&gt; dhcp_range.end = &#39;dead:beef::128&#39;
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range6 dead:beef::1 dead:beef::128;

        &gt;&gt;&gt; dhcp_range.temporary = True
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range6 dead:beef::1 dead:beef::128 temporary;

        &gt;&gt;&gt; dhcp_range = Range6(start=&#39;dead:beef:0:f1::/64&#39;)
        &gt;&gt;&gt; print(dhcp_range.to_isc())
        range6 dead:beef:0:f1::/64;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.ServerDuidEN"><code class="flex name class">
<span>class <span class="ident">ServerDuidEN</span></span>
<span>(</span><span>enterprise_number:int, enterprise_id:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an server DUID enterprise parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerDuidEN:
    &#34;&#34;&#34;Represents an server DUID enterprise parameter.&#34;&#34;&#34;
    def __init__(self, enterprise_number: int, enterprise_id: str) -&gt; None:
        self.enterprise_number = enterprise_number
        self.enterprise_id = enterprise_id

    def __str__(self) -&gt; str:
        return f&#39;server-duid EN {self.enterprise_number} {self.enterprise_id}&#39;

    def __repr__(self) -&gt; str:
        return (f&#39;ServerDuidEN(enterprise_number={self.enterprise_number}, &#39;
                f&#39;enterprise_id={self.enterprise_id})&#39;)

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; server_duid = ServerDuidEN(enterprise_number=9,
                              enterprise_id=&#39;&#34;a string of some significance&#34;&#39;)
            &gt;&gt;&gt; print(server_duid.to_isc())
            server-duid EN 9 &#34;a string of some significance&#34;;

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.ServerDuidEN.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.ServerDuidEN.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; server_duid = ServerDuidEN(enterprise_number=9,
                  enterprise_id='&quot;a string of some significance&quot;')
&gt;&gt;&gt; print(server_duid.to_isc())
server-duid EN 9 &quot;a string of some significance&quot;;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; server_duid = ServerDuidEN(enterprise_number=9,
                          enterprise_id=&#39;&#34;a string of some significance&#34;&#39;)
        &gt;&gt;&gt; print(server_duid.to_isc())
        server-duid EN 9 &#34;a string of some significance&#34;;

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.ServerDuidLL"><code class="flex name class">
<span>class <span class="ident">ServerDuidLL</span></span>
<span>(</span><span>hardware_type:str, hardware_address:str, timestamp:Union[int,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerDuidLL:
    def __init__(
        self,
        hardware_type:      str,
        hardware_address:   str,
        timestamp:          Union[int, None] = None
    ) -&gt; None:
        self.hardware_type = hardware_type
        self.hardware_address = hardware_address
        self.timestamp = timestamp

    def __str__(self) -&gt; str:
        if self.timestamp:
            return (f&#39;server-duid LLT {self.hardware_type} {self.timestamp} &#39;
                    f&#39;{self.hardware_address}&#39;)
        else:
            return (f&#39;server-duid LL {self.hardware_type} &#39;
                    f&#39;{self.hardware_address}&#39;)

    def __repr__(self) -&gt; str:
        return (f&#39;ServerDuidLL(hardware_type={self.hardware_type}, &#39;
                f&#39;hardware_address={self.hardware_address}, &#39;
                f&#39;timestamp={self.timestamp})&#39;)

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; pass

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.ServerDuidLL.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; pass
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; pass

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.SharedNetwork"><code class="flex name class">
<span>class <span class="ident">SharedNetwork</span></span>
<span>(</span><span>name:str, authoritative:Union[bool,NoneType]=None, options:Union[List[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>],NoneType]=None, subnets:Union[List[<a title="pyisc.dhcpd.nodes.Subnet4" href="#pyisc.dhcpd.nodes.Subnet4">Subnet4</a>],NoneType]=None, pools:Union[List[<a title="pyisc.dhcpd.nodes.Pool4" href="#pyisc.dhcpd.nodes.Pool4">Pool4</a>],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an shared network declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the Shared Network.</dd>
<dt><strong><code>authoritative</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Authoritative state.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>]</code></dt>
<dd>List of options.</dd>
<dt><strong><code>ranges</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>]</code></dt>
<dd>List of ranges.</dd>
<dt><strong><code>pools</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Pool4" href="#pyisc.dhcpd.nodes.Pool4">Pool4</a>]</code></dt>
<dd>List of pools.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SharedNetwork(Parameters, Permissions, OptionMixin, SubnetMixin,
                    PoolMixin):
    &#34;&#34;&#34;Represents an shared network declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:           str,
        authoritative:  Union[bool, None] = None,
        options:        Union[List[Option], None] = None,
        subnets:        Union[List[Subnet4], None] = None,
        pools:          Union[List[Pool4], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): Name of the Shared Network.
            authoritative (boolean): Authoritative state.
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of ranges.
            pools (list[pyisc.dhcpd.nodes.Pool4]): List of pools.

        &#34;&#34;&#34;
        self.name = name
        self.authoritative = authoritative
        self.options = [] if not options else options
        self.subnets = [] if not subnets else subnets
        self.pools = [] if not pools else pools

    def __str__(self) -&gt; str:
        return f&#39;shared-network {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;SharedNetwork(name={self.name})&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; shared_network = SharedNetwork(name=&#39;&#34;test&#34;&#39;)
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
            }

            &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
            &gt;&gt;&gt; shared_network.add_subnet(subnet)
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
            }

            &gt;&gt;&gt; shared_network.authoritative = True
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
            authoritative;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
            }

            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;, end=&#39;10.10.10.250&#39;)
            &gt;&gt;&gt; pool.add_range(dhcp_range)
            &gt;&gt;&gt; shared_network.add_pool(pool)
            &gt;&gt;&gt; print(shared_network.to_isc())
            shared-network &#34;test&#34; {
            authoritative;
                subnet 10.10.10.0 netmask 255.255.255.0 {
                }
                pool {
                    allow members of &#34;foo&#34;;
                    range 10.10.10.10 10.10.10.250;
                }
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{key};&#39;)
                else:
                    attrs.append(f&#39;not {key};&#39;)
            elif all((value, key != &#39;name&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
<li><a title="pyisc.dhcpd.mixin.Permissions" href="mixin.html#pyisc.dhcpd.mixin.Permissions">Permissions</a></li>
<li><a title="pyisc.dhcpd.mixin.OptionMixin" href="mixin.html#pyisc.dhcpd.mixin.OptionMixin">OptionMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.SubnetMixin" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin">SubnetMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.PoolMixin" href="mixin.html#pyisc.dhcpd.mixin.PoolMixin">PoolMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.SharedNetwork.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; shared_network = SharedNetwork(name='&quot;test&quot;')
&gt;&gt;&gt; print(shared_network.to_isc())
shared-network &quot;test&quot; {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; subnet = Subnet4('10.10.10.0/24')
&gt;&gt;&gt; shared_network.add_subnet(subnet)
&gt;&gt;&gt; print(shared_network.to_isc())
shared-network &quot;test&quot; {
    subnet 10.10.10.0 netmask 255.255.255.0 {
    }
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; shared_network.authoritative = True
&gt;&gt;&gt; print(shared_network.to_isc())
shared-network &quot;test&quot; {
authoritative;
    subnet 10.10.10.0 netmask 255.255.255.0 {
    }
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool = Pool4()
&gt;&gt;&gt; pool.add_allowed_member('&quot;foo&quot;')
&gt;&gt;&gt; dhcp_range = Range4(start='10.10.10.10', end='10.10.10.250')
&gt;&gt;&gt; pool.add_range(dhcp_range)
&gt;&gt;&gt; shared_network.add_pool(pool)
&gt;&gt;&gt; print(shared_network.to_isc())
shared-network &quot;test&quot; {
authoritative;
    subnet 10.10.10.0 netmask 255.255.255.0 {
    }
    pool {
        allow members of &quot;foo&quot;;
        range 10.10.10.10 10.10.10.250;
    }
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; shared_network = SharedNetwork(name=&#39;&#34;test&#34;&#39;)
        &gt;&gt;&gt; print(shared_network.to_isc())
        shared-network &#34;test&#34; {
        }

        &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
        &gt;&gt;&gt; shared_network.add_subnet(subnet)
        &gt;&gt;&gt; print(shared_network.to_isc())
        shared-network &#34;test&#34; {
            subnet 10.10.10.0 netmask 255.255.255.0 {
            }
        }

        &gt;&gt;&gt; shared_network.authoritative = True
        &gt;&gt;&gt; print(shared_network.to_isc())
        shared-network &#34;test&#34; {
        authoritative;
            subnet 10.10.10.0 netmask 255.255.255.0 {
            }
        }

        &gt;&gt;&gt; pool = Pool4()
        &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
        &gt;&gt;&gt; dhcp_range = Range4(start=&#39;10.10.10.10&#39;, end=&#39;10.10.10.250&#39;)
        &gt;&gt;&gt; pool.add_range(dhcp_range)
        &gt;&gt;&gt; shared_network.add_pool(pool)
        &gt;&gt;&gt; print(shared_network.to_isc())
        shared-network &#34;test&#34; {
        authoritative;
            subnet 10.10.10.0 netmask 255.255.255.0 {
            }
            pool {
                allow members of &#34;foo&#34;;
                range 10.10.10.10 10.10.10.250;
            }
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc(indent=child_indent))
        elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
            if value:
                attrs.append(f&#39;{key};&#39;)
            else:
                attrs.append(f&#39;not {key};&#39;)
        elif all((value, key != &#39;name&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyisc.dhcpd.mixin.SubnetMixin" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin">SubnetMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.add_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.add_subnet">add_subnet</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.all_subnets" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.all_subnets">all_subnets</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.delete_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.delete_subnet">delete_subnet</a></code></li>
<li><code><a title="pyisc.dhcpd.mixin.SubnetMixin.find_subnet" href="mixin.html#pyisc.dhcpd.mixin.SubnetMixin.find_subnet">find_subnet</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyisc.dhcpd.nodes.SubClass"><code class="flex name class">
<span>class <span class="ident">SubClass</span></span>
<span>(</span><span>name:str, match_value:str, lease_limit:Union[int,NoneType]=None, options:Union[List[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an subclass declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the zone.</dd>
<dt><strong><code>match_value</code></strong> :&ensp;<code>str</code></dt>
<dd>The conditional in the form of a string.</dd>
<dt><strong><code>lease_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets the amount of clients that are allowed a
lease.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>]</code></dt>
<dd>A list of options.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubClass(Parameters, OptionMixin):
    &#34;&#34;&#34;Represents an subclass declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:           str,
        match_value:    str,
        lease_limit:    Union[int, None] = None,
        options:        Union[List[Option], None] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            match_value (str): The conditional in the form of a string.
            lease_limit (int): Sets the amount of clients that are allowed a
                lease.
            options (list[pyisc.dhcpd.nodes.Option]): A list of options.

        &#34;&#34;&#34;
        self.name = name
        self.match_value = match_value
        self.lease_limit = lease_limit
        self.options = [] if not options else options
        super().__init__()

    def __str__(self) -&gt; str:
        return f&#39;subclass {self.name} {self.match_value}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;SubClass(name={self.name}, match_value={self.match_value})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; subclass = SubClass(name=&#39;&#34;foo&#34;&#39;,
                                    match_value=&#39;1:08:00:2b:a1:11:31&#39;)
            &gt;&gt;&gt; print(subclass.to_isc())
            subclass &#34;foo&#34; 1:08:00:2b:a1:11:31;

            &gt;&gt;&gt; subclass.lease_limit = 4
            &gt;&gt;&gt; print(subclass.to_isc())
            subclass &#34;foo&#34; 1:08:00:2b:a1:11:31 {
                lease limit 4;
            }

            &gt;&gt;&gt; option = Option(name=&#39;domain-name-servers&#39;,
                                value=&#39;ns1.example.org, ns2.example.org&#39;)
            &gt;&gt;&gt; subclass.add_option(option)
            &gt;&gt;&gt; print(subclass.to_isc())
            subclass &#34;foo&#34; 1:08:00:2b:a1:11:31 {
                lease limit 4;
                option domain-name-servers ns1.example.org, ns2.example.org;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if key == &#39;lease_limit&#39;:
                new_key = key.replace(&#34;_&#34;, &#34; &#34;)
            else:
                new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((value, key != &#39;name&#39;, key != &#39;match_value&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
        if len(attrs) == 0:
            return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39; &#39;\n&#39;)
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
<li><a title="pyisc.dhcpd.mixin.OptionMixin" href="mixin.html#pyisc.dhcpd.mixin.OptionMixin">OptionMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.SubClass.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.SubClass.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; subclass = SubClass(name='&quot;foo&quot;',
                        match_value='1:08:00:2b:a1:11:31')
&gt;&gt;&gt; print(subclass.to_isc())
subclass &quot;foo&quot; 1:08:00:2b:a1:11:31;
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; subclass.lease_limit = 4
&gt;&gt;&gt; print(subclass.to_isc())
subclass &quot;foo&quot; 1:08:00:2b:a1:11:31 {
    lease limit 4;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; option = Option(name='domain-name-servers',
                    value='ns1.example.org, ns2.example.org')
&gt;&gt;&gt; subclass.add_option(option)
&gt;&gt;&gt; print(subclass.to_isc())
subclass &quot;foo&quot; 1:08:00:2b:a1:11:31 {
    lease limit 4;
    option domain-name-servers ns1.example.org, ns2.example.org;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; subclass = SubClass(name=&#39;&#34;foo&#34;&#39;,
                                match_value=&#39;1:08:00:2b:a1:11:31&#39;)
        &gt;&gt;&gt; print(subclass.to_isc())
        subclass &#34;foo&#34; 1:08:00:2b:a1:11:31;

        &gt;&gt;&gt; subclass.lease_limit = 4
        &gt;&gt;&gt; print(subclass.to_isc())
        subclass &#34;foo&#34; 1:08:00:2b:a1:11:31 {
            lease limit 4;
        }

        &gt;&gt;&gt; option = Option(name=&#39;domain-name-servers&#39;,
                            value=&#39;ns1.example.org, ns2.example.org&#39;)
        &gt;&gt;&gt; subclass.add_option(option)
        &gt;&gt;&gt; print(subclass.to_isc())
        subclass &#34;foo&#34; 1:08:00:2b:a1:11:31 {
            lease limit 4;
            option domain-name-servers ns1.example.org, ns2.example.org;
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if key == &#39;lease_limit&#39;:
            new_key = key.replace(&#34;_&#34;, &#34; &#34;)
        else:
            new_key = key.replace(&#34;_&#34;, &#34;-&#34;)
        if isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc(indent=child_indent))
        elif all((value, key != &#39;name&#39;, key != &#39;match_value&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{new_key} {value};&#39;)
    if len(attrs) == 0:
        return f&#39;{&#34; &#34; * indent}{self.__str__()};&#39;
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39; &#39;\n&#39;)
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Subnet4"><code class="flex name class">
<span>class <span class="ident">Subnet4</span></span>
<span>(</span><span>network:str, authoritative:Union[bool,NoneType]=None, server_id_check:Union[bool,NoneType]=None, options:Union[List[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>],NoneType]=None, ranges:Union[List[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>],NoneType]=None, pools:Union[List[<a title="pyisc.dhcpd.nodes.Pool4" href="#pyisc.dhcpd.nodes.Pool4">Pool4</a>],NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an subnet declaration for IPv4 objects.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code></dt>
<dd>The network in CIDR format.</dd>
<dt><strong><code>authoritative</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Authoritative state.</dd>
<dt><strong><code>server_id_check</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Tells the server to verify value of
dhcp-server-identifier option.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>]</code></dt>
<dd>List of options.</dd>
<dt><strong><code>ranges</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>]</code></dt>
<dd>List of ranges.</dd>
<dt><strong><code>pools</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Pool4" href="#pyisc.dhcpd.nodes.Pool4">Pool4</a>]</code></dt>
<dd>List of pools.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Subnet4(Parameters, Permissions, OptionMixin, RangeMixin, PoolMixin):
    &#34;&#34;&#34;Represents an subnet declaration for IPv4 objects.&#34;&#34;&#34;
    def __init__(
        self,
        network:            str,
        authoritative:      Union[bool, None] = None,
        server_id_check:    Union[bool, None] = None,
        options:            Union[List[Option], None] = None,
        ranges:             Union[List[Range4], None] = None,
        pools:              Union[List[Pool4], None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            network (str): The network in CIDR format.
            authoritative (boolean): Authoritative state.
            server_id_check (boolean): Tells the server to verify value of
                dhcp-server-identifier option.
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of ranges.
            pools (list[pyisc.dhcpd.nodes.Pool4]): List of pools.

        &#34;&#34;&#34;
        self.network = IPv4Network(network).with_prefixlen
        self.authoritative = authoritative
        self.server_id_check = server_id_check
        self.options = [] if not options else options
        self.ranges = [] if not ranges else ranges
        self.pools = [] if not pools else pools
        super().__init__()

    # def __lt__(self, other: object) -&gt; bool:
    #     return IPv4Network(self.network) &lt; IPv4Network(other.network)

    # def __eq__(self, other: object) -&gt; bool:
    #     if other is None:
    #         return False
    #     return (
    #         IPv4Network(self.network) == IPv4Network(other.network)
    #     )

    def __str__(self) -&gt; str:
        ip_network = IPv4Network(self.network)
        subnet, netmask = ip_network.with_netmask.split(&#39;/&#39;)
        return f&#39;subnet {subnet} netmask {netmask}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Subnet4(network=&#34;{self.network}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
            }

            &gt;&gt;&gt; subnet.authoritative = True
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
                authoritative;
            }

            &gt;&gt;&gt; pool = Pool4()
            &gt;&gt;&gt; pool.known_clients = &#39;allow&#39;
            &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
            &gt;&gt;&gt; subnet.add_pool(pool)
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
                authoritative;
                pool {
                    allow known-clients;
                    allow members of &#34;foo&#34;;
                }
            }

            &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
            &gt;&gt;&gt; subnet.add_option(option)
            &gt;&gt;&gt; print(subnet.to_isc())
            subnet 10.10.10.0 netmask 255.255.255.0 {
                authoritative;
                option domain-name &#34;example.org&#34;;
                pool {
                    allow known-clients;
                    allow members of &#34;foo&#34;;
                }
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{key};&#39;)
                else:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}not {key};&#39;)
            elif all((value, key != &#39;network&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
<li><a title="pyisc.dhcpd.mixin.Permissions" href="mixin.html#pyisc.dhcpd.mixin.Permissions">Permissions</a></li>
<li><a title="pyisc.dhcpd.mixin.OptionMixin" href="mixin.html#pyisc.dhcpd.mixin.OptionMixin">OptionMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.RangeMixin" href="mixin.html#pyisc.dhcpd.mixin.RangeMixin">RangeMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.PoolMixin" href="mixin.html#pyisc.dhcpd.mixin.PoolMixin">PoolMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Subnet4.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Subnet4.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; subnet = Subnet4('10.10.10.0/24')
&gt;&gt;&gt; print(subnet.to_isc())
subnet 10.10.10.0 netmask 255.255.255.0 {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; subnet.authoritative = True
&gt;&gt;&gt; print(subnet.to_isc())
subnet 10.10.10.0 netmask 255.255.255.0 {
    authoritative;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; pool = Pool4()
&gt;&gt;&gt; pool.known_clients = 'allow'
&gt;&gt;&gt; pool.add_allowed_member('&quot;foo&quot;')
&gt;&gt;&gt; subnet.add_pool(pool)
&gt;&gt;&gt; print(subnet.to_isc())
subnet 10.10.10.0 netmask 255.255.255.0 {
    authoritative;
    pool {
        allow known-clients;
        allow members of &quot;foo&quot;;
    }
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; option = Option(name='domain-name', value='&quot;example.org&quot;')
&gt;&gt;&gt; subnet.add_option(option)
&gt;&gt;&gt; print(subnet.to_isc())
subnet 10.10.10.0 netmask 255.255.255.0 {
    authoritative;
    option domain-name &quot;example.org&quot;;
    pool {
        allow known-clients;
        allow members of &quot;foo&quot;;
    }
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; subnet = Subnet4(&#39;10.10.10.0/24&#39;)
        &gt;&gt;&gt; print(subnet.to_isc())
        subnet 10.10.10.0 netmask 255.255.255.0 {
        }

        &gt;&gt;&gt; subnet.authoritative = True
        &gt;&gt;&gt; print(subnet.to_isc())
        subnet 10.10.10.0 netmask 255.255.255.0 {
            authoritative;
        }

        &gt;&gt;&gt; pool = Pool4()
        &gt;&gt;&gt; pool.known_clients = &#39;allow&#39;
        &gt;&gt;&gt; pool.add_allowed_member(&#39;&#34;foo&#34;&#39;)
        &gt;&gt;&gt; subnet.add_pool(pool)
        &gt;&gt;&gt; print(subnet.to_isc())
        subnet 10.10.10.0 netmask 255.255.255.0 {
            authoritative;
            pool {
                allow known-clients;
                allow members of &#34;foo&#34;;
            }
        }

        &gt;&gt;&gt; option = Option(name=&#39;domain-name&#39;, value=&#39;&#34;example.org&#34;&#39;)
        &gt;&gt;&gt; subnet.add_option(option)
        &gt;&gt;&gt; print(subnet.to_isc())
        subnet 10.10.10.0 netmask 255.255.255.0 {
            authoritative;
            option domain-name &#34;example.org&#34;;
            pool {
                allow known-clients;
                allow members of &#34;foo&#34;;
            }
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc(indent=child_indent))
        elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
            if value:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key};&#39;)
            else:
                attrs.append(f&#39;{&#34; &#34; * child_indent}not {key};&#39;)
        elif all((value, key != &#39;network&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Subnet6"><code class="flex name class">
<span>class <span class="ident">Subnet6</span></span>
<span>(</span><span>network:str, authoritative:Union[bool,NoneType]=None, server_id_check:Union[bool,NoneType]=None, options:Union[List[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>],NoneType]=None, ranges:Union[List[<a title="pyisc.dhcpd.nodes.Range6" href="#pyisc.dhcpd.nodes.Range6">Range6</a>],NoneType]=None, pools:Union[List[<a title="pyisc.dhcpd.nodes.Pool6" href="#pyisc.dhcpd.nodes.Pool6">Pool6</a>],NoneType]=None, prefix6:Union[<a title="pyisc.dhcpd.nodes.Prefix6" href="#pyisc.dhcpd.nodes.Prefix6">Prefix6</a>,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an subnet declaration for IPv6 objects.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code></dt>
<dd>The network in CIDR format.</dd>
<dt><strong><code>authoritative</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Authoritative state.</dd>
<dt><strong><code>server_id_check</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Tells the server to verify value of
dhcp-server-identifier option.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a>]</code></dt>
<dd>List of options.</dd>
<dt><strong><code>ranges</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a>]</code></dt>
<dd>List of ranges.</dd>
<dt><strong><code>pools</code></strong> :&ensp;<code>list[<a title="pyisc.dhcpd.nodes.Pool4" href="#pyisc.dhcpd.nodes.Pool4">Pool4</a>]</code></dt>
<dd>List of pools.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Subnet6(Parameters, Permissions, OptionMixin, RangeMixin, PoolMixin):
    &#34;&#34;&#34;Represents an subnet declaration for IPv6 objects.&#34;&#34;&#34;
    def __init__(
        self,
        network:            str,
        authoritative:      Union[bool, None] = None,
        server_id_check:    Union[bool, None] = None,
        options:            Union[List[Option], None] = None,
        ranges:             Union[List[Range6], None] = None,
        pools:              Union[List[Pool6], None] = None,
        prefix6:            Union[Prefix6, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            network (str): The network in CIDR format.
            authoritative (boolean): Authoritative state.
            server_id_check (boolean): Tells the server to verify value of
                dhcp-server-identifier option.
            options (list[pyisc.dhcpd.nodes.Option]): List of options.
            ranges (list[pyisc.dhcpd.nodes.Range4]): List of ranges.
            pools (list[pyisc.dhcpd.nodes.Pool4]): List of pools.

        &#34;&#34;&#34;
        self.network = IPv6Network(network).with_prefixlen
        self.authoritative = authoritative
        self.server_id_check = server_id_check
        self.options = [] if not options else options
        self.ranges = [] if not ranges else ranges
        self.pools = [] if not pools else pools
        self.prefix6 = prefix6
        super().__init__()

    # def __lt__(self, other: object) -&gt; bool:
    #     return IPv6Network(self.network) &lt; IPv6Network(other.network)

    # def __eq__(self, other: object) -&gt; bool:
    #     if other is None:
    #         return False
    #     return (
    #         IPv6Network(self.network) == IPv6Network(other.network)
    #     )

    def __str__(self) -&gt; str:
        return f&#39;subnet6 {self.network}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Subnet6(network=&#34;{self.network}&#34;)&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; pass

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if isinstance(value, list):
                for item in value:
                    attrs.append(item.to_isc(indent=child_indent))
            elif hasattr(value, &#39;to_isc&#39;):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
            elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
                if value:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}{key};&#39;)
                else:
                    attrs.append(f&#39;{&#34; &#34; * child_indent}not {key};&#39;)
            elif all((value, key != &#39;network&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyisc.dhcpd.mixin.Parameters" href="mixin.html#pyisc.dhcpd.mixin.Parameters">Parameters</a></li>
<li><a title="pyisc.dhcpd.mixin.Permissions" href="mixin.html#pyisc.dhcpd.mixin.Permissions">Permissions</a></li>
<li><a title="pyisc.dhcpd.mixin.OptionMixin" href="mixin.html#pyisc.dhcpd.mixin.OptionMixin">OptionMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.RangeMixin" href="mixin.html#pyisc.dhcpd.mixin.RangeMixin">RangeMixin</a></li>
<li><a title="pyisc.dhcpd.mixin.PoolMixin" href="mixin.html#pyisc.dhcpd.mixin.PoolMixin">PoolMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Subnet6.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Subnet6.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; pass
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; pass

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if isinstance(value, list):
            for item in value:
                attrs.append(item.to_isc(indent=child_indent))
        elif hasattr(value, &#39;to_isc&#39;):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value.to_isc()}&#39;)
        elif all((isinstance(value, bool), key == &#39;authoritative&#39;)):
            if value:
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key};&#39;)
            else:
                attrs.append(f&#39;{&#34; &#34; * child_indent}not {key};&#39;)
        elif all((value, key != &#39;network&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyisc.dhcpd.nodes.Zone"><code class="flex name class">
<span>class <span class="ident">Zone</span></span>
<span>(</span><span>name:str, primary:Union[str,NoneType]=None, primary6:Union[str,NoneType]=None, secondary:Union[str,NoneType]=None, secondary6:Union[str,NoneType]=None, key:Union[<a title="pyisc.dhcpd.nodes.Key" href="#pyisc.dhcpd.nodes.Key">Key</a>,NoneType]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an zone declaration.</p>
<p>Initialize attributes for the class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the zone.</dd>
<dt><strong><code>primary</code></strong> :&ensp;<code>str</code></dt>
<dd>The IP address of the primary server for the zone
in string format.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code><a title="pyisc.dhcpd.nodes.Key" href="#pyisc.dhcpd.nodes.Key">Key</a></code></dt>
<dd>The key used to authenticate to the
primary server.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Zone:
    &#34;&#34;&#34;Represents an zone declaration.&#34;&#34;&#34;
    def __init__(
        self,
        name:       str,
        primary:    Union[str, None] = None,
        primary6:   Union[str, None] = None,
        secondary:  Union[str, None] = None,
        secondary6: Union[str, None] = None,
        key:        Union[Key, None] = None
    ) -&gt; None:
        &#34;&#34;&#34;Initialize attributes for the class.

        Args:
            name (str): The name of the zone.
            primary (str): The IP address of the primary server for the zone
                in string format.
            key (pyisc.dhcpd.nodes.Key): The key used to authenticate to the
                primary server.

        &#34;&#34;&#34;
        self.name = name
        self.primary = primary
        self.primary6 = primary6
        self.secondary = secondary
        self.secondary6 = secondary6
        self.key = key

    def __str__(self) -&gt; str:
        return f&#39;zone {self.name}&#39;

    def __repr__(self) -&gt; str:
        return f&#39;Zone(name={self.name})&#39;

    def object_tree(self, indent=0):
        return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;

    def to_isc(self, indent: int = 0) -&gt; str:
        &#34;&#34;&#34;Returns valid ISC configuration as a string.

        Args:
            indent (int): Supply an integer to use as indentation offset.
                Default is 0.

        Examples:
            &gt;&gt;&gt; zone = Zone(name=&#39;EXAMPLE.ORG.&#39;)
            &gt;&gt;&gt; print(zone.to_isc())
            zone EXAMPLE.ORG. {
            }

            &gt;&gt;&gt; zone.primary = &#39;127.0.0.1&#39;
            &gt;&gt;&gt; print(zone.to_isc())
            zone EXAMPLE.ORG. {
                primary 127.0.0.1;
            }

            &gt;&gt;&gt; zone.key = Key(name=&#39;DHCP_UPDATER&#39;)
            &gt;&gt;&gt; print(zone.to_isc())
            zone EXAMPLE.ORG. {
                primary 127.0.0.1;
                key DHCP_UPDATER;
            }

        Returns:
            str: A string representation of the object tree from this level.

        &#34;&#34;&#34;
        attrs = []
        child_indent = indent+4
        for key, value in self.__dict__.items():
            if all((value, key != &#39;name&#39;, key != &#39;key&#39;)):
                attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
        if self.key:
            attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
        return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
        if len(attrs) &gt; 0:
            return_str += &#39;\n&#39;
        attrs_str = &#34;\n&#34;.join(attrs)
        section_end = &#39;}&#39;
        return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyisc.dhcpd.nodes.Zone.object_tree"><code class="name flex">
<span>def <span class="ident">object_tree</span></span>(<span>self, indent=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object_tree(self, indent=0):
    return f&#39;{&#34; &#34; * indent}{self.__repr__()}&#39;</code></pre>
</details>
</dd>
<dt id="pyisc.dhcpd.nodes.Zone.to_isc"><code class="name flex">
<span>def <span class="ident">to_isc</span></span>(<span>self, indent:int=0) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns valid ISC configuration as a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code></dt>
<dd>Supply an integer to use as indentation offset.
Default is 0.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; zone = Zone(name='EXAMPLE.ORG.')
&gt;&gt;&gt; print(zone.to_isc())
zone EXAMPLE.ORG. {
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; zone.primary = '127.0.0.1'
&gt;&gt;&gt; print(zone.to_isc())
zone EXAMPLE.ORG. {
    primary 127.0.0.1;
}
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; zone.key = Key(name='DHCP_UPDATER')
&gt;&gt;&gt; print(zone.to_isc())
zone EXAMPLE.ORG. {
    primary 127.0.0.1;
    key DHCP_UPDATER;
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A string representation of the object tree from this level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_isc(self, indent: int = 0) -&gt; str:
    &#34;&#34;&#34;Returns valid ISC configuration as a string.

    Args:
        indent (int): Supply an integer to use as indentation offset.
            Default is 0.

    Examples:
        &gt;&gt;&gt; zone = Zone(name=&#39;EXAMPLE.ORG.&#39;)
        &gt;&gt;&gt; print(zone.to_isc())
        zone EXAMPLE.ORG. {
        }

        &gt;&gt;&gt; zone.primary = &#39;127.0.0.1&#39;
        &gt;&gt;&gt; print(zone.to_isc())
        zone EXAMPLE.ORG. {
            primary 127.0.0.1;
        }

        &gt;&gt;&gt; zone.key = Key(name=&#39;DHCP_UPDATER&#39;)
        &gt;&gt;&gt; print(zone.to_isc())
        zone EXAMPLE.ORG. {
            primary 127.0.0.1;
            key DHCP_UPDATER;
        }

    Returns:
        str: A string representation of the object tree from this level.

    &#34;&#34;&#34;
    attrs = []
    child_indent = indent+4
    for key, value in self.__dict__.items():
        if all((value, key != &#39;name&#39;, key != &#39;key&#39;)):
            attrs.append(f&#39;{&#34; &#34; * child_indent}{key} {value};&#39;)
    if self.key:
        attrs.append(f&#39;{&#34; &#34; * child_indent}{value};&#39;)
    return_str = (f&#39;{&#34; &#34; * indent}{self.__str__()}&#39; &#39; {&#39;)
    if len(attrs) &gt; 0:
        return_str += &#39;\n&#39;
    attrs_str = &#34;\n&#34;.join(attrs)
    section_end = &#39;}&#39;
    return (f&#39;{return_str}{attrs_str}&#39; &#39;\n&#39; f&#39;{&#34; &#34; * indent}{section_end}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyisc.dhcpd" href="index.html">pyisc.dhcpd</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.CustomOption" href="#pyisc.dhcpd.nodes.CustomOption">CustomOption</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.CustomOption.to_isc" href="#pyisc.dhcpd.nodes.CustomOption.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.DhcpClass" href="#pyisc.dhcpd.nodes.DhcpClass">DhcpClass</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.DhcpClass.object_tree" href="#pyisc.dhcpd.nodes.DhcpClass.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.DhcpClass.to_isc" href="#pyisc.dhcpd.nodes.DhcpClass.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Event" href="#pyisc.dhcpd.nodes.Event">Event</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Event.object_tree" href="#pyisc.dhcpd.nodes.Event.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Event.to_isc" href="#pyisc.dhcpd.nodes.Event.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.EventSet" href="#pyisc.dhcpd.nodes.EventSet">EventSet</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.EventSet.object_tree" href="#pyisc.dhcpd.nodes.EventSet.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.EventSet.to_isc" href="#pyisc.dhcpd.nodes.EventSet.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Failover" href="#pyisc.dhcpd.nodes.Failover">Failover</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Failover.object_tree" href="#pyisc.dhcpd.nodes.Failover.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Failover.to_isc" href="#pyisc.dhcpd.nodes.Failover.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Global" href="#pyisc.dhcpd.nodes.Global">Global</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Global.add_custom_option" href="#pyisc.dhcpd.nodes.Global.add_custom_option">add_custom_option</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Global.add_option_expression" href="#pyisc.dhcpd.nodes.Global.add_option_expression">add_option_expression</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Global.delete_custom_option" href="#pyisc.dhcpd.nodes.Global.delete_custom_option">delete_custom_option</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Global.delete_option_expression" href="#pyisc.dhcpd.nodes.Global.delete_option_expression">delete_option_expression</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Global.find_custom_option" href="#pyisc.dhcpd.nodes.Global.find_custom_option">find_custom_option</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Global.find_option_expression" href="#pyisc.dhcpd.nodes.Global.find_option_expression">find_option_expression</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Global.to_isc" href="#pyisc.dhcpd.nodes.Global.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Group" href="#pyisc.dhcpd.nodes.Group">Group</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Group.to_isc" href="#pyisc.dhcpd.nodes.Group.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Hardware" href="#pyisc.dhcpd.nodes.Hardware">Hardware</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Hardware.object_tree" href="#pyisc.dhcpd.nodes.Hardware.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Hardware.to_isc" href="#pyisc.dhcpd.nodes.Hardware.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Host" href="#pyisc.dhcpd.nodes.Host">Host</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Host.object_tree" href="#pyisc.dhcpd.nodes.Host.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Host.to_isc" href="#pyisc.dhcpd.nodes.Host.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.HostIdentifier" href="#pyisc.dhcpd.nodes.HostIdentifier">HostIdentifier</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.HostIdentifier.object_tree" href="#pyisc.dhcpd.nodes.HostIdentifier.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.HostIdentifier.to_isc" href="#pyisc.dhcpd.nodes.HostIdentifier.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Include" href="#pyisc.dhcpd.nodes.Include">Include</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Include.object_tree" href="#pyisc.dhcpd.nodes.Include.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Include.to_isc" href="#pyisc.dhcpd.nodes.Include.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Key" href="#pyisc.dhcpd.nodes.Key">Key</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Key.object_tree" href="#pyisc.dhcpd.nodes.Key.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Key.to_isc" href="#pyisc.dhcpd.nodes.Key.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Option" href="#pyisc.dhcpd.nodes.Option">Option</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Option.object_tree" href="#pyisc.dhcpd.nodes.Option.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Option.to_isc" href="#pyisc.dhcpd.nodes.Option.to_isc">to_isc</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Option.value" href="#pyisc.dhcpd.nodes.Option.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.OptionExpression" href="#pyisc.dhcpd.nodes.OptionExpression">OptionExpression</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.OptionExpression.to_isc" href="#pyisc.dhcpd.nodes.OptionExpression.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Pool4" href="#pyisc.dhcpd.nodes.Pool4">Pool4</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Pool4.add_allowed_member" href="#pyisc.dhcpd.nodes.Pool4.add_allowed_member">add_allowed_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool4.add_denied_member" href="#pyisc.dhcpd.nodes.Pool4.add_denied_member">add_denied_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool4.delete_allowed_member" href="#pyisc.dhcpd.nodes.Pool4.delete_allowed_member">delete_allowed_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool4.delete_denied_member" href="#pyisc.dhcpd.nodes.Pool4.delete_denied_member">delete_denied_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool4.object_tree" href="#pyisc.dhcpd.nodes.Pool4.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool4.to_isc" href="#pyisc.dhcpd.nodes.Pool4.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Pool6" href="#pyisc.dhcpd.nodes.Pool6">Pool6</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Pool6.add_allowed_member" href="#pyisc.dhcpd.nodes.Pool6.add_allowed_member">add_allowed_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool6.add_denied_member" href="#pyisc.dhcpd.nodes.Pool6.add_denied_member">add_denied_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool6.delete_allowed_member" href="#pyisc.dhcpd.nodes.Pool6.delete_allowed_member">delete_allowed_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool6.delete_denied_member" href="#pyisc.dhcpd.nodes.Pool6.delete_denied_member">delete_denied_member</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool6.object_tree" href="#pyisc.dhcpd.nodes.Pool6.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Pool6.to_isc" href="#pyisc.dhcpd.nodes.Pool6.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Prefix6" href="#pyisc.dhcpd.nodes.Prefix6">Prefix6</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Prefix6.object_tree" href="#pyisc.dhcpd.nodes.Prefix6.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Prefix6.to_isc" href="#pyisc.dhcpd.nodes.Prefix6.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Range4" href="#pyisc.dhcpd.nodes.Range4">Range4</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Range4.object_tree" href="#pyisc.dhcpd.nodes.Range4.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Range4.to_isc" href="#pyisc.dhcpd.nodes.Range4.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Range6" href="#pyisc.dhcpd.nodes.Range6">Range6</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Range6.object_tree" href="#pyisc.dhcpd.nodes.Range6.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Range6.to_isc" href="#pyisc.dhcpd.nodes.Range6.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.ServerDuidEN" href="#pyisc.dhcpd.nodes.ServerDuidEN">ServerDuidEN</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.ServerDuidEN.object_tree" href="#pyisc.dhcpd.nodes.ServerDuidEN.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.ServerDuidEN.to_isc" href="#pyisc.dhcpd.nodes.ServerDuidEN.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.ServerDuidLL" href="#pyisc.dhcpd.nodes.ServerDuidLL">ServerDuidLL</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.ServerDuidLL.to_isc" href="#pyisc.dhcpd.nodes.ServerDuidLL.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.SharedNetwork" href="#pyisc.dhcpd.nodes.SharedNetwork">SharedNetwork</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.SharedNetwork.to_isc" href="#pyisc.dhcpd.nodes.SharedNetwork.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.SubClass" href="#pyisc.dhcpd.nodes.SubClass">SubClass</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.SubClass.object_tree" href="#pyisc.dhcpd.nodes.SubClass.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.SubClass.to_isc" href="#pyisc.dhcpd.nodes.SubClass.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Subnet4" href="#pyisc.dhcpd.nodes.Subnet4">Subnet4</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Subnet4.object_tree" href="#pyisc.dhcpd.nodes.Subnet4.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Subnet4.to_isc" href="#pyisc.dhcpd.nodes.Subnet4.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Subnet6" href="#pyisc.dhcpd.nodes.Subnet6">Subnet6</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Subnet6.object_tree" href="#pyisc.dhcpd.nodes.Subnet6.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Subnet6.to_isc" href="#pyisc.dhcpd.nodes.Subnet6.to_isc">to_isc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyisc.dhcpd.nodes.Zone" href="#pyisc.dhcpd.nodes.Zone">Zone</a></code></h4>
<ul class="">
<li><code><a title="pyisc.dhcpd.nodes.Zone.object_tree" href="#pyisc.dhcpd.nodes.Zone.object_tree">object_tree</a></code></li>
<li><code><a title="pyisc.dhcpd.nodes.Zone.to_isc" href="#pyisc.dhcpd.nodes.Zone.to_isc">to_isc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>